=== simple return
fn Foo() -> int {
    return 1
}
fn Main() -> void { WritelnOut(ToString(Foo())) }
---
Foo.always_returns = true
---

=== no return
fn Foo() -> void {
    WritelnOut("hi")
}
fn Main() -> void { Foo() }
---
Foo.always_returns = false
---

=== if else both return
fn Foo(x: int) -> int {
    if x > 0 {
        return 1
    } else {
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo(1))) }
---
Foo.always_returns = true
Foo.body.0.type = TIfStmt
Foo.body.0.always_returns = true
---

=== if no else
fn Foo(x: int) -> int {
    if x > 0 {
        return 1
    }
    return 0
}
fn Main() -> void { WritelnOut(ToString(Foo(1))) }
---
Foo.always_returns = true
Foo.body.0.type = TIfStmt
Foo.body.0.always_returns = false
---

=== while always false
fn Foo() -> void {
    while true {
        return
    }
}
fn Main() -> void { Foo() }
---
Foo.body.0.type = TWhileStmt
Foo.body.0.always_returns = false
---

=== for always false
fn Foo() -> void {
    let xs: list[int] = [1, 2, 3]
    for x in xs {
        return
    }
}
fn Main() -> void { Foo() }
---
Foo.body.1.type = TForStmt
Foo.body.1.always_returns = false
---

=== match all arms return
interface Shape {}
struct Circle : Shape { radius: int }
struct Rect : Shape { w: int h: int }
fn Describe(s: Shape) -> string {
    match s {
        case c: Circle {
            return "circle"
        }
        case r: Rect {
            return "rect"
        }
    }
}
fn Main() -> void { WritelnOut(Describe(Circle(radius: 1))) }
---
Describe.always_returns = true
Describe.body.0.type = TMatchStmt
Describe.body.0.always_returns = true
Describe.body.0.cases.0.always_returns = true
Describe.body.0.cases.1.always_returns = true
---

=== match missing arm
interface Shape {}
struct Circle : Shape { radius: int }
struct Rect : Shape { w: int h: int }
fn Describe(s: Shape) -> string {
    match s {
        case c: Circle {
            return "circle"
        }
        case r: Rect {
            WritelnOut("rect")
        }
    }
    return "unknown"
}
fn Main() -> void { WritelnOut(Describe(Circle(radius: 1))) }
---
Describe.body.0.type = TMatchStmt
Describe.body.0.always_returns = false
---

=== try catch both return
fn Foo(s: string) -> int {
    try {
        return ParseInt(s, 10)
    } catch e: ValueError {
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo("42"))) }
---
Foo.always_returns = true
Foo.body.0.type = TTryStmt
Foo.body.0.always_returns = true
---

=== throw terminator
fn Foo() -> int {
    throw ValueError(message: "nope")
}
fn Main() -> void {
    try {
        WritelnOut(ToString(Foo()))
    } catch e: ValueError {
        WritelnOut("caught")
    }
}
---
Foo.always_returns = true
---

=== exit terminator
fn Foo() -> void {
    Exit(1)
}
fn Main() -> void { Foo() }
---
Foo.always_returns = true
---

=== nested compound
fn Foo(x: int) -> int {
    if x > 0 {
        if x > 10 {
            return 100
        } else {
            return 1
        }
    } else {
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo(5))) }
---
Foo.always_returns = true
---

=== catch body has return
fn Foo(s: string) -> int {
    try {
        return ParseInt(s, 10)
    } catch e: ValueError {
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo("42"))) }
---
Foo.needs_named_returns = true
---

=== no try catch
fn Foo() -> int {
    return 1
}
fn Main() -> void { WritelnOut(ToString(Foo())) }
---
Foo.needs_named_returns = false
---

=== try catch without returns
fn Foo() -> void {
    try {
        WritelnOut("hi")
    } catch e: ValueError {
        WritelnOut("err")
    }
}
fn Main() -> void { Foo() }
---
Foo.needs_named_returns = false
---

=== nested try in if
fn Foo(x: int, s: string) -> int {
    if x > 0 {
        try {
            return ParseInt(s, 10)
        } catch e: ValueError {
            return 0
        }
    }
    return x
}
fn Main() -> void { WritelnOut(ToString(Foo(1, "42"))) }
---
Foo.needs_named_returns = true
---

=== return nil
fn Foo() -> int? {
    return nil
}
fn Main() -> void {
    let x: int? = Foo()
    WritelnOut(ToString(0))
}
---
Foo.may_return_nil = true
---

=== return optional var no narrowing
fn Foo(x: int?) -> int? {
    return x
}
fn Main() -> void {
    let r: int? = Foo(nil)
    WritelnOut(ToString(0))
}
---
Foo.may_return_nil = true
---

=== return narrowed var
fn Foo(x: int?) -> int {
    if x != nil {
        return x
    }
    return 0
}
fn Main() -> void { WritelnOut(ToString(Foo(1))) }
---
Foo.may_return_nil = false
---

=== return int literal
fn Foo() -> int {
    return 42
}
fn Main() -> void { WritelnOut(ToString(Foo())) }
---
Foo.may_return_nil = false
---

=== return call with optional return
fn MaybeNil() -> int? {
    return nil
}
fn Foo() -> int? {
    return MaybeNil()
}
fn Main() -> void {
    let r: int? = Foo()
    WritelnOut(ToString(0))
}
---
Foo.may_return_nil = true
---

=== bare return
fn Foo() -> void {
    return
}
fn Main() -> void { Foo() }
---
Foo.may_return_nil = false
---

=== return in try body
fn Foo(s: string) -> int {
    try {
        return ParseInt(s, 10)
    } catch e: ValueError {
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo("42"))) }
---
Foo.body.0.type = TTryStmt
Foo.body.0.body_has_return = true
---

=== no return in try body
fn Foo() -> void {
    try {
        WritelnOut("hi")
    } catch e: ValueError {
        WritelnOut("err")
    }
}
fn Main() -> void { Foo() }
---
Foo.body.0.type = TTryStmt
Foo.body.0.body_has_return = false
---

=== nested return in if inside try
fn Foo(x: int, s: string) -> int {
    try {
        if x > 0 {
            return ParseInt(s, 10)
        }
    } catch e: ValueError {
        WritelnOut("err")
    }
    return 0
}
fn Main() -> void { WritelnOut(ToString(Foo(1, "42"))) }
---
Foo.body.0.type = TTryStmt
Foo.body.0.body_has_return = true
---

=== method annotations
struct Calc {
    value: int
    fn Get(self) -> int {
        return self.value
    }
}
fn Main() -> void {
    let c: Calc = Calc(value: 42)
    WritelnOut(ToString(c.Get()))
}
---
Calc.Get.always_returns = true
Calc.Get.needs_named_returns = false
Calc.Get.may_return_nil = false
---

=== match with default all return
interface Shape {}
struct Circle : Shape { radius: int }
struct Rect : Shape { w: int h: int }
fn Describe(s: Shape) -> string {
    match s {
        case c: Circle {
            return "circle"
        }
        default {
            return "other"
        }
    }
}
fn Main() -> void { WritelnOut(Describe(Circle(radius: 1))) }
---
Describe.always_returns = true
Describe.body.0.type = TMatchStmt
Describe.body.0.always_returns = true
Describe.body.0.default.always_returns = true
---

=== catch always returns
fn Foo(s: string) -> int {
    try {
        return ParseInt(s, 10)
    } catch e: ValueError {
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo("42"))) }
---
Foo.body.0.type = TTryStmt
Foo.body.0.catches.0.always_returns = true
---
