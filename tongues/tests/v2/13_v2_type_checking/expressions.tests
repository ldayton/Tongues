=== arithmetic int
fn Main() -> void {
    let a: int = 1 + 2
    let b: int = a * 3
    let c: int = b - a
    let d: int = c / 2
    let e: int = d % 3
}
---
ok
---

=== arithmetic float
fn Main() -> void {
    let a: float = 1.0 + 2.0
    let b: float = a * 3.0
    let c: float = b / 2.0
}
---
ok
---

=== arithmetic type mismatch int and float
fn Main() -> void {
    let x: int = 1 + 1.0
}
---
error:
---

=== string plus rejected
fn Main() -> void {
    let s: string = "a" + "b"
}
---
error:
---

=== comparison operators
fn Main() -> void {
    let a: bool = 1 < 2
    let b: bool = 3 >= 2
    let c: bool = 1 == 1
    let d: bool = 1 != 2
}
---
ok
---

=== string comparison
fn Main() -> void {
    let a: bool = "abc" < "def"
    let b: bool = "abc" == "abc"
}
---
ok
---

=== logical operators
fn Main() -> void {
    let a: bool = true && false
    let b: bool = true || false
    let c: bool = !true
}
---
ok
---

=== bitwise operators
fn Main() -> void {
    let a: int = 1 & 2
    let b: int = 1 | 2
    let c: int = 1 ^ 2
    let d: int = ~1
    let e: int = 1 << 2
    let f: int = 8 >> 1
}
---
ok
---

=== ternary expression
fn Main() -> void {
    let x: int = true ? 1 : 2
}
---
ok
---

=== ternary condition must be bool
fn Main() -> void {
    let x: int = 42 ? 1 : 2
}
---
error:
---

=== field access on struct
struct Pt {
    x: int
    y: int
}
fn Main() -> void {
    let p: Pt = Pt(1, 2)
    let x: int = p.x
}
---
ok
---

=== list indexing
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    let x: int = xs[0]
}
---
ok
---

=== map indexing
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    let v: int = m["a"]
}
---
ok
---

=== string indexing yields rune
fn Main() -> void {
    let s: string = "hello"
    let c: rune = s[0]
}
---
ok
---

=== bytes indexing yields byte
fn Main() -> void {
    let b: bytes = b"\x89PNG"
    let x: byte = b[0]
}
---
ok
---

=== list slicing preserves type
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    let ys: list[int] = xs[0:2]
}
---
ok
---

=== string slicing yields string
fn Main() -> void {
    let s: string = "hello"
    let sub: string = s[1:3]
}
---
ok
---

=== cannot index union type
fn Foo(v: list[int] | string) -> void {
    let x: int = v[0]
}
fn Main() -> void {
}
---
error: cannot index union
---

=== ordering not defined for union
fn Foo(v: int | string) -> bool {
    return v < v
}
fn Main() -> void {
}
---
error: not defined for union
---

=== negation
fn Main() -> void {
    let x: int = -42
    let y: float = -3.14
}
---
ok
---

=== unary not requires bool
fn Main() -> void {
    let x: bool = !42
}
---
error:
---

=== bitwise not on int
fn Main() -> void {
    let x: int = ~0
}
---
ok
---

=== tuple field access
fn Main() -> void {
    let t: (int, string) = (1, "hello")
    let x: int = t.0
    let s: string = t.1
}
---
ok
---

=== enum variant access
enum Color {
    Red
    Green
    Blue
}
fn Main() -> void {
    let c: Color = Color.Red
    let eq: bool = c == Color.Green
}
---
ok
---
