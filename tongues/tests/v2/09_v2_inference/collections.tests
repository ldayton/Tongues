=== list append correct type allowed
def f(xs: list[int]) -> None:
    xs.append(1)
---
ok
---

=== list extend correct type allowed
def f(xs: list[int]) -> None:
    xs.extend([1, 2, 3])
---
ok
---

=== list insert correct type allowed
def f(xs: list[int]) -> None:
    xs.insert(0, 1)
---
ok
---

=== list index returns element type
def f(xs: list[int]) -> int:
    return xs[0]
---
ok
---

=== list slice returns same list type
def f(xs: list[int]) -> list[int]:
    return xs[1:3]
---
ok
---

=== list pop returns element type
def f(xs: list[int]) -> int:
    return xs.pop()
---
ok
---

=== list iteration yields element type
def f(xs: list[int]) -> int:
    total: int = 0
    for x in xs:
        total += x
    return total
---
ok
---

=== list comprehension element type
def f(xs: list[int]) -> list[str]:
    return [str(x) for x in xs]
---
ok
---

=== dict get returns value type
def f(d: dict[str, int], key: str) -> int | None:
    return d.get(key)
---
ok
---

=== dict index returns value type
def f(d: dict[str, int], key: str) -> int:
    return d[key]
---
ok
---

=== dict assignment correct types allowed
def f(d: dict[str, int]) -> None:
    d["key"] = 42
---
ok
---

=== dict keys returns key type
def f(d: dict[str, int]) -> list[str]:
    return list(d.keys())
---
ok
---

=== dict values returns value type
def f(d: dict[str, int]) -> list[int]:
    return list(d.values())
---
ok
---

=== dict items returns tuple type
def f(d: dict[str, int]) -> list[tuple[str, int]]:
    return list(d.items())
---
ok
---

=== dict iteration yields key type
def f(d: dict[str, int]) -> list[str]:
    result: list[str] = []
    for k in d:
        result.append(k)
    return result
---
ok
---

=== set add correct type allowed
def f(s: set[int]) -> None:
    s.add(1)
---
ok
---

=== set union returns same type
def f(a: set[int], b: set[int]) -> set[int]:
    return a.union(b)
---
ok
---

=== set intersection returns same type
def f(a: set[int], b: set[int]) -> set[int]:
    return a.intersection(b)
---
ok
---

=== set iteration yields element type
def f(s: set[int]) -> int:
    total: int = 0
    for x in s:
        total += x
    return total
---
ok
---

=== nested list element type
def f(xs: list[list[int]]) -> int:
    return xs[0][0]
---
ok
---

=== dict with list value type
def f(d: dict[str, list[int]]) -> int:
    return d["key"][0]
---
ok
---

=== list append wrong type not allowed
def f(xs: list[int]) -> None:
    xs.append("hello")
---
error: type
---

=== list extend wrong type not allowed
def f(xs: list[int]) -> None:
    xs.extend(["a", "b"])
---
error: type
---

=== list insert wrong type not allowed
def f(xs: list[int]) -> None:
    xs.insert(0, "hello")
---
error: type
---

=== dict wrong key type not allowed
def f(d: dict[str, int]) -> None:
    d[42] = 1
---
error: type
---

=== dict wrong value type not allowed
def f(d: dict[str, int]) -> None:
    d["key"] = "hello"
---
error: type
---

=== set add wrong type not allowed
def f(s: set[int]) -> None:
    s.add("hello")
---
error: type
---

=== list concatenation type mismatch not allowed
def f(xs: list[int], ys: list[str]) -> list[int]:
    return xs + ys
---
error: type
---

=== assigning wrong list type not allowed
def f() -> None:
    xs: list[int] = ["a", "b", "c"]
---
error: type
---

=== return wrong element type not allowed
def f(xs: list[int]) -> str:
    return xs[0]
---
error: type
---

=== list literal with mixed types not allowed
def f() -> list[int]:
    return [1, "two", 3]
---
error: type
---

=== dict literal wrong key type not allowed
def f() -> dict[str, int]:
    return {1: "one", 2: "two"}
---
error: type
---

=== empty list with annotation allowed
def f() -> list[int]:
    xs: list[int] = []
    return xs
---
ok
---

=== empty dict with annotation allowed
def f() -> dict[str, int]:
    d: dict[str, int] = {}
    return d
---
ok
---

=== empty set with annotation allowed
def f() -> set[int]:
    s: set[int] = set()
    return s
---
ok
---

=== list copy preserves type
def f(xs: list[int]) -> list[int]:
    return xs.copy()
---
ok
---

=== dict copy preserves type
def f(d: dict[str, int]) -> dict[str, int]:
    return d.copy()
---
ok
---

=== set copy preserves type
def f(s: set[int]) -> set[int]:
    return s.copy()
---
ok
---

=== sorted returns list of element type
def f(xs: list[int]) -> list[int]:
    return sorted(xs)
---
ok
---

=== reversed in list returns same type
def f(xs: list[int]) -> list[int]:
    return list(reversed(xs))
---
ok
---
