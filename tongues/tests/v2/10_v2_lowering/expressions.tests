=== int literal
def f() -> int:
    return 42
---
return 42
---

=== hex literal preserved
def f() -> int:
    return 0xff
---
0xff
---

=== float literal
def f() -> float:
    return 3.14
---
return 3.14
---

=== string literal
def f() -> str:
    return "hello"
---
return "hello"
---

=== bool true
def f() -> bool:
    return True
---
return true
---

=== bool false
def f() -> bool:
    return False
---
return false
---

=== none literal
def f() -> int | None:
    return None
---
return nil
---

=== struct construction positional
from dataclasses import dataclass
@dataclass
class Pt:
    x: int
    y: int
def f() -> Pt:
    return Pt(1, 2)
---
return Pt(1, 2)
---

=== is None
def f(x: int | None) -> bool:
    return x is None
---
x == nil
---

=== is not None
def f(x: int | None) -> bool:
    return x is not None
---
x != nil
---

=== isinstance check
class Node:
    def __init__(self) -> None:
        pass
class Leaf(Node):
    def __init__(self, val: int) -> None:
        self.val = val
def f(n: Node) -> bool:
    return isinstance(n, Leaf)
---
Leaf
---

=== fstring
def f(name: str) -> str:
    return f"hello {name}"
---
Format("hello {}", name)
---

=== ternary
def f(x: int) -> str:
    return "pos" if x > 0 else "neg"
---
x > 0 ? "pos" : "neg"
---

=== list literal
def f() -> list[int]:
    return [1, 2, 3]
---
[1, 2, 3]
---

=== empty typed list
def f() -> list[int]:
    xs: list[int] = []
    return xs
---
let xs: list[int]
---

=== dict literal
def f() -> dict[str, int]:
    return {"a": 1, "b": 2}
---
{"a": 1, "b": 2}
---

=== set literal
def f() -> set[int]:
    return {1, 2, 3}
---
{1, 2, 3}
---

=== tuple literal
def f() -> tuple[int, str]:
    return (1, "hi")
---
(1, "hi")
---

=== tuple index becomes field access
def f(t: tuple[int, str]) -> int:
    return t[0]
---
t.0
---

=== list comprehension
def f(xs: list[int]) -> list[int]:
    return [x * 2 for x in xs]
---
for x in xs
---

=== negative index resolved
def f(xs: list[int]) -> int:
    return xs[-1]
---
xs[Len(xs) - 1]
---

=== slice open start
def f(xs: list[int]) -> list[int]:
    return xs[:3]
---
xs[0:3]
---

=== slice open end
def f(xs: list[int]) -> list[int]:
    return xs[2:]
---
xs[2:Len(xs)]
---

=== bytes literal
def f() -> bytes:
    return b"\x89PNG"
---
b"\x89PNG"
---

=== chained comparison desugared
def f(x: int) -> bool:
    return 0 < x < 100
---
0 < x && x < 100
---

=== in tuple desugared to or
def f(x: int) -> bool:
    return x in (1, 2, 3)
---
||
---

=== function call
def add(a: int, b: int) -> int:
    return a + b
def f() -> int:
    return add(1, 2)
---
return add(1, 2)
---

=== method call
from dataclasses import dataclass
@dataclass
class Buf:
    items: list[int]
    def count(self) -> int:
        return len(self.items)
def f(b: Buf) -> int:
    return b.count()
---
b.count()
---
