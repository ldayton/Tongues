=== for has continue
fn SumPositive(xs: list[int]) -> int {
    let total: int = 0
    for x in xs {
        if x < 0 {
            continue
        }
        total += x
    }
    return total
}
fn Main() -> void { WritelnOut(ToString(SumPositive([1, -2, 3]))) }
---
SumPositive.body.1.type = TForStmt
SumPositive.body.1.has_continue = true
---

=== for no continue
fn Total(xs: list[int]) -> int {
    let total: int = 0
    for x in xs {
        total += x
    }
    return total
}
fn Main() -> void { WritelnOut(ToString(Total([1, 2, 3]))) }
---
Total.body.1.type = TForStmt
Total.body.1.has_continue = false
---

=== while has continue
fn Main() -> void {
    let i: int = 0
    while i < 10 {
        i += 1
        if i % 2 == 0 {
            continue
        }
        WritelnOut(ToString(i))
    }
}
---
Main.body.1.type = TWhileStmt
Main.body.1.has_continue = true
---

=== while no continue
fn Main() -> void {
    let i: int = 0
    while i < 5 {
        WritelnOut(ToString(i))
        i += 1
    }
}
---
Main.body.1.type = TWhileStmt
Main.body.1.has_continue = false
---

=== continue nested in if counts
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4, 5]
    for x in xs {
        if x % 2 == 0 {
            continue
        }
        WritelnOut(ToString(x))
    }
}
---
Main.body.1.type = TForStmt
Main.body.1.has_continue = true
---

=== continue in nested loop not counted
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    for x in xs {
        let ys: list[int] = [4, 5, 6]
        for y in ys {
            if y == 5 {
                continue
            }
            WritelnOut(ToString(x + y))
        }
    }
}
---
Main.body.1.type = TForStmt
Main.body.1.has_continue = false
---

=== continue in nested while not counted
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    for x in xs {
        let i: int = 0
        while i < 3 {
            i += 1
            if i == 2 {
                continue
            }
            WritelnOut(ToString(x + i))
        }
    }
}
---
Main.body.1.type = TForStmt
Main.body.1.has_continue = false
---

=== match has break
fn Process(xs: list[int | string]) -> void {
    for item in xs {
        match item {
            case n: int {
                if n < 0 {
                    break
                }
                WritelnOut(ToString(n))
            }
            case s: string {
                WritelnOut(s)
            }
        }
    }
}
fn Main() -> void { Process([1, "hi", -1]) }
---
Process.body.0.type = TForStmt
---

=== match no break
interface Shape {}
struct Circle : Shape { radius: int }
struct Rect : Shape { w: int h: int }
fn Describe(s: Shape) -> string {
    match s {
        case c: Circle {
            return "circle"
        }
        case r: Rect {
            return "rect"
        }
    }
}
fn Main() -> void { WritelnOut(Describe(Circle(radius: 5))) }
---
Describe.body.0.type = TMatchStmt
Describe.body.0.has_break = false
---

=== break nested in if inside match counts
fn Process(xs: list[int | string]) -> void {
    for item in xs {
        match item {
            case n: int {
                if n < 0 {
                    if n == -1 {
                        break
                    }
                }
                WritelnOut(ToString(n))
            }
            case s: string {
                WritelnOut(s)
            }
        }
    }
}
fn Main() -> void { Process([1, -1]) }
---
Process.body.0.type = TForStmt
---

=== break in nested loop inside match not counted
fn Process(xs: list[int | string]) -> void {
    for item in xs {
        match item {
            case n: int {
                let ys: list[int] = [1, 2, 3]
                for y in ys {
                    if y == n {
                        break
                    }
                }
                WritelnOut(ToString(n))
            }
            case s: string {
                WritelnOut(s)
            }
        }
    }
}
fn Main() -> void { Process([2, "hi"]) }
---
Process.body.0.type = TForStmt
---

=== break in nested match inside match counts
enum Color { Red Green Blue }
fn Process(xs: list[Color]) -> void {
    for c in xs {
        match c {
            case Color.Red {
                match c {
                    case Color.Red {
                        break
                    }
                    default {
                        WritelnOut("other")
                    }
                }
            }
            default {
                WritelnOut("not red")
            }
        }
    }
}
fn Main() -> void { Process([Color.Red, Color.Blue]) }
---
Process.body.0.type = TForStmt
---

=== enum match has break
enum Color { Red Green Blue }
fn FindRed(xs: list[Color]) -> void {
    for c in xs {
        match c {
            case Color.Red {
                WritelnOut("found red")
                break
            }
            default {
                WritelnOut("skip")
            }
        }
    }
}
fn Main() -> void { FindRed([Color.Blue, Color.Red]) }
---
FindRed.body.0.type = TForStmt
---

=== enum match no break
enum Color { Red Green Blue }
fn PrintColors(xs: list[Color]) -> void {
    for c in xs {
        match c {
            case Color.Red {
                WritelnOut("red")
            }
            case Color.Green {
                WritelnOut("green")
            }
            case Color.Blue {
                WritelnOut("blue")
            }
        }
    }
}
fn Main() -> void { PrintColors([Color.Red, Color.Blue]) }
---
PrintColors.body.0.type = TForStmt
---

=== rune var from index
fn CharAt(s: string, i: int) -> rune {
    return s[i]
}
fn Main() -> void { WritelnOut(ToString(RuneToInt(CharAt("abc", 0)))) }
---
CharAt.rune_vars = s
---

=== rune var from slice
fn Prefix(s: string, n: int) -> string {
    return s[0:n]
}
fn Main() -> void { WritelnOut(Prefix("hello", 3)) }
---
Prefix.rune_vars = s
---

=== no rune vars
fn Greet(name: string) -> void {
    WritelnOut(Concat("hello ", name))
}
fn Main() -> void { Greet("world") }
---
Greet.rune_vars =
---

=== multiple rune vars
fn Swap(a: string, b: string, i: int) -> (rune, rune) {
    return (b[i], a[i])
}
fn Main() -> void {
    let x: rune
    let y: rune
    x, y = Swap("abc", "xyz", 0)
    WritelnOut(ToString(RuneToInt(x)))
}
---
Swap.rune_vars = a,b
---

=== rune var from both index and slice
fn Middle(s: string) -> rune {
    let half: int = Len(s) / 2
    let sub: string = s[0:half]
    return s[half]
}
fn Main() -> void { WritelnOut(ToString(RuneToInt(Middle("abcde")))) }
---
Middle.rune_vars = s
---

=== string not indexed not rune var
fn Process(s: string) -> int {
    return Len(s)
}
fn Main() -> void { WritelnOut(ToString(Process("hello"))) }
---
Process.rune_vars =
---

=== continue in match inside loop counts
fn Process(xs: list[int | string]) -> void {
    for item in xs {
        match item {
            case n: int {
                if n < 0 {
                    continue
                }
                WritelnOut(ToString(n))
            }
            case s: string {
                WritelnOut(s)
            }
        }
    }
}
fn Main() -> void { Process([1, "hi", -1]) }
---
Process.body.0.type = TForStmt
Process.body.0.has_continue = true
---

=== continue in try inside loop counts
fn Main() -> void {
    let xs: list[string] = ["1", "x", "3"]
    for s in xs {
        try {
            WritelnOut(ToString(ParseInt(s, 10)))
            continue
        } catch e: ValueError {
            WritelnOut("skip")
        }
    }
}
---
Main.body.1.type = TForStmt
Main.body.1.has_continue = true
---

=== method rune vars
struct Finder {
    text: string
    fn CharAt(self, i: int) -> rune {
        return self.text[i]
    }
}
fn Main() -> void {
    let f: Finder = Finder(text: "abc")
    WritelnOut(ToString(RuneToInt(f.CharAt(0))))
}
---
Finder.CharAt.rune_vars = text
---

=== method has continue
struct Processor {
    items: list[int]
    fn Run(self) -> int {
        let total: int = 0
        for x in self.items {
            if x < 0 {
                continue
            }
            total += x
        }
        return total
    }
}
fn Main() -> void {
    let p: Processor = Processor(items: [1, -2, 3])
    WritelnOut(ToString(p.Run()))
}
---
Processor.Run.body.1.type = TForStmt
Processor.Run.body.1.has_continue = true
---

=== break in try inside match counts
fn Process(xs: list[int | string]) -> void {
    for item in xs {
        match item {
            case n: int {
                try {
                    if n < 0 {
                        break
                    }
                } catch e: ValueError {
                    WritelnOut("err")
                }
                WritelnOut(ToString(n))
            }
            case s: string {
                WritelnOut(s)
            }
        }
    }
}
fn Main() -> void { Process([1, -1]) }
---
Process.body.0.type = TForStmt
---

=== let indexed string rune var
fn Main() -> void {
    let s: string = "hello"
    let ch: rune = s[2]
    WritelnOut(ToString(RuneToInt(ch)))
}
---
Main.rune_vars = s
---

=== let not indexed no rune var
fn Main() -> void {
    let s: string = "hello"
    WritelnOut(s)
}
---
Main.rune_vars =
---

=== param and let both indexed
fn Process(s: string) -> rune {
    let t: string = "world"
    WritelnOut(ToString(RuneToInt(t[0])))
    return s[0]
}
fn Main() -> void { WritelnOut(ToString(RuneToInt(Process("abc")))) }
---
Process.rune_vars = s,t
---

=== for range has continue
fn Main() -> void {
    for i in range(10) {
        if i % 2 == 0 {
            continue
        }
        WritelnOut(ToString(i))
    }
}
---
Main.body.0.type = TForStmt
Main.body.0.has_continue = true
---

=== for range no continue
fn Main() -> void {
    for i in range(5) {
        WritelnOut(ToString(i))
    }
}
---
Main.body.0.type = TForStmt
Main.body.0.has_continue = false
---

=== break in while inside match not counted
fn Process(xs: list[int | string]) -> void {
    for item in xs {
        match item {
            case n: int {
                let i: int = 0
                while i < n {
                    i += 1
                    if i == 3 {
                        break
                    }
                }
                WritelnOut(ToString(n))
            }
            case s: string {
                WritelnOut(s)
            }
        }
    }
}
fn Main() -> void { Process([5, "hi"]) }
---
Process.body.0.type = TForStmt
---

=== optional match has break
fn Process(xs: list[int?]) -> void {
    for item in xs {
        match item {
            case n: int {
                if n < 0 {
                    break
                }
                WritelnOut(ToString(n))
            }
            case nil {
                WritelnOut("nil")
            }
        }
    }
}
fn Main() -> void { Process([1, nil, -1]) }
---
Process.body.0.type = TForStmt
---

=== union match has break
fn Process(xs: list[int | string | bool]) -> void {
    for item in xs {
        match item {
            case n: int {
                if n < 0 {
                    break
                }
                WritelnOut(ToString(n))
            }
            case s: string {
                WritelnOut(s)
            }
            case b: bool {
                WritelnOut(ToString(b))
            }
        }
    }
}
fn Main() -> void { Process([1, "hi", false, -1]) }
---
Process.body.0.type = TForStmt
---
