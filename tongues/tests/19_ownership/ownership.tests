=== constructor owned
struct Pt {
    x: int
    y: int
}
fn Main() -> void {
    let p: Pt = Pt(x: 1, y: 2)
    WritelnOut(ToString(p.x))
}
---
Main.lets.p.kind = owned
---

=== list literal owned
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    WritelnOut(ToString(Len(xs)))
}
---
Main.lets.xs.kind = owned
---

=== map literal owned
fn Main() -> void {
    let m: map[string, int] = {"a": 1, "b": 2}
    WritelnOut(ToString(Len(m)))
}
---
Main.lets.m.kind = owned
---

=== set literal owned
fn Main() -> void {
    let s: set[int] = {1, 2, 3}
    WritelnOut(ToString(Len(s)))
}
---
Main.lets.s.kind = owned
---

=== empty list owned
fn Main() -> void {
    let xs: list[int] = []
    Append(xs, 1)
    WritelnOut(ToString(Len(xs)))
}
---
Main.lets.xs.kind = owned
---

=== empty map owned
fn Main() -> void {
    let m: map[string, int] = Map()
    WritelnOut(ToString(Len(m)))
}
---
Main.lets.m.kind = owned
---

=== empty set owned
fn Main() -> void {
    let s: set[int] = Set()
    WritelnOut(ToString(Len(s)))
}
---
Main.lets.s.kind = owned
---

=== function return value owned
fn MakeList() -> list[int] {
    return [1, 2, 3]
}
fn Main() -> void {
    let xs: list[int] = MakeList()
    WritelnOut(ToString(Len(xs)))
}
---
Main.lets.xs.kind = owned
---

=== parameter borrowed
struct Pt {
    x: int
    y: int
}
fn Show(p: Pt) -> void {
    WritelnOut(ToString(p.x))
}
fn Main() -> void { Show(Pt(x: 1, y: 2)) }
---
Show.params.p.kind = borrowed
---

=== parameter int borrowed
fn Double(x: int) -> int {
    return x * 2
}
fn Main() -> void { WritelnOut(ToString(Double(5))) }
---
Double.params.x.kind = borrowed
---

=== parameter list borrowed
fn Total(xs: list[int]) -> int {
    let total: int = 0
    for x in xs {
        total += x
    }
    return total
}
fn Main() -> void { WritelnOut(ToString(Total([1, 2, 3]))) }
---
Total.params.xs.kind = borrowed
---

=== parameter string borrowed
fn Greet(name: string) -> void {
    WritelnOut(Concat("hi ", name))
}
fn Main() -> void { Greet("world") }
---
Greet.params.name.kind = borrowed
---

=== field access borrowed
struct Wrapper {
    items: list[int]
}
fn First(w: Wrapper) -> list[int] {
    let xs: list[int] = w.items
    return xs
}
fn Main() -> void {
    let w: Wrapper = Wrapper(items: [1, 2])
    WritelnOut(ToString(Len(First(w))))
}
---
First.lets.xs.kind = borrowed
---

=== index expression borrowed
fn First(xs: list[string]) -> string {
    let s: string = xs[0]
    return s
}
fn Main() -> void { WritelnOut(First(["a", "b"])) }
---
First.lets.s.kind = borrowed
---

=== map index borrowed
fn Lookup(m: map[string, int], k: string) -> int {
    let v: int = m[k]
    return v
}
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    WritelnOut(ToString(Lookup(m, "a")))
}
---
Lookup.lets.v.kind = borrowed
---

=== both branches owned stays owned
fn Build(flag: bool) -> list[int] {
    let result: list[int]
    if flag {
        result = [1, 2, 3]
    } else {
        result = [4, 5, 6]
    }
    return result
}
fn Main() -> void { WritelnOut(ToString(Len(Build(true)))) }
---
Build.lets.result.kind = owned
---

=== both branches constructors stays owned
struct Pt {
    x: int
    y: int
}
fn MakePt(flag: bool) -> Pt {
    let p: Pt = Pt(x: 0, y: 0)
    if flag {
        p = Pt(x: 1, y: 2)
    } else {
        p = Pt(x: 3, y: 4)
    }
    return p
}
fn Main() -> void { WritelnOut(ToString(MakePt(true))) }
---
MakePt.lets.p.kind = owned
---

=== one branch owned one borrowed shared
struct Wrapper {
    items: list[int]
}
fn GetItems(w: Wrapper, flag: bool) -> list[int] {
    let xs: list[int]
    if flag {
        xs = [1, 2, 3]
    } else {
        xs = w.items
    }
    return xs
}
fn Main() -> void {
    let w: Wrapper = Wrapper(items: [4, 5])
    WritelnOut(ToString(Len(GetItems(w, true))))
}
---
GetItems.lets.xs.kind = shared
---

=== one branch param one branch literal shared
fn Choose(xs: list[int], flag: bool) -> list[int] {
    let result: list[int]
    if flag {
        result = xs
    } else {
        result = [0]
    }
    return result
}
fn Main() -> void { WritelnOut(ToString(Len(Choose([1], true)))) }
---
Choose.lets.result.kind = shared
---

=== dead init skipped
fn Main() -> void {
    let xs: list[int] = [99]
    xs = [1, 2, 3]
    WritelnOut(ToString(Len(xs)))
}
---
Main.lets.xs.kind = owned
---

=== return escapes
struct Pt {
    x: int
    y: int
}
fn MakePt() -> Pt {
    let p: Pt = Pt(x: 1, y: 2)
    return p
}
fn Main() -> void { WritelnOut(ToString(MakePt().x)) }
---
MakePt.lets.p.kind = owned
MakePt.escapes.p = true
---

=== return borrowed escapes
fn First(xs: list[string]) -> string {
    let s: string = xs[0]
    return s
}
fn Main() -> void { WritelnOut(First(["hello"])) }
---
First.lets.s.kind = borrowed
First.escapes.s = true
---

=== no return no escape
struct Pt {
    x: int
    y: int
}
fn Show(p: Pt) -> void {
    WritelnOut(ToString(p.x))
}
fn Main() -> void { Show(Pt(x: 1, y: 2)) }
---
Show.params.p.kind = borrowed
---

=== append escapes
fn Push(xs: list[int], v: int) -> void {
    Append(xs, v)
}
fn Main() -> void {
    let xs: list[int] = [1]
    Push(xs, 2)
    WritelnOut(ToString(Len(xs)))
}
---
Push.escapes.v = true
---

=== set add escapes
fn AddItem(s: set[int], v: int) -> void {
    Add(s, v)
}
fn Main() -> void {
    let s: set[int] = {1}
    AddItem(s, 2)
    WritelnOut(ToString(Len(s)))
}
---
AddItem.escapes.v = true
---

=== map assign escapes
fn SetKey(m: map[string, int], k: string, v: int) -> void {
    m[k] = v
}
fn Main() -> void {
    let m: map[string, int] = Map()
    SetKey(m, "a", 1)
    WritelnOut(ToString(Len(m)))
}
---
SetKey.escapes.v = true
SetKey.escapes.k = true
---

=== struct field assign escapes
struct Wrapper {
    value: string
}
fn SetValue(w: Wrapper, s: string) -> void {
    w.value = s
}
fn Main() -> void {
    let w: Wrapper = Wrapper(value: "old")
    SetValue(w, "new")
    WritelnOut(w.value)
}
---
SetValue.escapes.s = true
---

=== throw escapes
struct MyError {
    message: string
}
fn Fail(msg: string) -> void {
    throw MyError(message: msg)
}
fn Main() -> void {
    try {
        Fail("oops")
    } catch e: MyError {
        WritelnOut(e.message)
    }
}
---
Fail.escapes.msg = true
---

=== local not returned not escape
fn Compute() -> int {
    let xs: list[int] = [1, 2, 3]
    let total: int = 0
    for x in xs {
        total += x
    }
    return total
}
fn Main() -> void { WritelnOut(ToString(Compute())) }
---
Compute.lets.xs.kind = owned
---

=== param not mutated not escape
fn Length(xs: list[int]) -> int {
    return Len(xs)
}
fn Main() -> void { WritelnOut(ToString(Length([1, 2]))) }
---
Length.params.xs.kind = borrowed
---

=== same scope same region
struct Pt {
    x: int
    y: int
}
fn Foo() -> void {
    let a: Pt = Pt(x: 1, y: 2)
    let b: Pt = Pt(x: 3, y: 4)
    WritelnOut(ToString(a.x + b.x))
}
fn Main() -> void { Foo() }
---
Foo.lets.a.region = Foo.lets.b.region
---

=== params same region
fn Add(a: int, b: int) -> int {
    return a + b
}
fn Main() -> void { WritelnOut(ToString(Add(1, 2))) }
---
Add.params.a.region = Add.params.b.region
---

=== spec example MakeToken
enum TokenKind {
    Ident
    Number
    Eof
}
struct Token {
    kind: TokenKind
    value: string
    offset: int
}
fn MakeToken(kind: TokenKind, value: string) -> Token {
    let t: Token = Token(kind, value, 0)
    return t
}
fn Main() -> void {
    let t: Token = MakeToken(TokenKind.Ident, "foo")
    WritelnOut(t.value)
}
---
MakeToken.params.kind.kind = borrowed
MakeToken.params.value.kind = borrowed
MakeToken.lets.t.kind = owned
MakeToken.escapes.t = true
---

=== spec example Append3
fn Append3(xs: list[int], a: int, b: int, c: int) -> void {
    Append(xs, a)
    Append(xs, b)
    Append(xs, c)
}
fn Main() -> void {
    let xs: list[int] = []
    Append3(xs, 1, 2, 3)
    WritelnOut(ToString(Len(xs)))
}
---
Append3.params.xs.kind = borrowed
Append3.escapes.a = true
Append3.escapes.b = true
Append3.escapes.c = true
---

=== spec example First
fn First(xs: list[string]) -> string {
    let s: string = xs[0]
    return s
}
fn Main() -> void { WritelnOut(First(["hello"])) }
---
First.lets.s.kind = borrowed
First.escapes.s = true
---

=== spec example Build both owned
fn Build(flag: bool) -> list[int] {
    let result: list[int]
    if flag {
        result = [1, 2, 3]
    } else {
        result = [4, 5, 6]
    }
    return result
}
fn Main() -> void { WritelnOut(ToString(Len(Build(true)))) }
---
Build.lets.result.kind = owned
Build.escapes.result = true
---

=== for binder borrowed
fn PrintAll(xs: list[int]) -> void {
    for x in xs {
        WritelnOut(ToString(x))
    }
}
fn Main() -> void { PrintAll([1, 2, 3]) }
---
PrintAll.body.0.type = TForStmt
PrintAll.body.0.binder.x.kind = borrowed
---

=== for two binders borrowed
fn PrintIndexed(xs: list[string]) -> void {
    for i, s in xs {
        WritelnOut(Concat(ToString(i), Concat(": ", s)))
    }
}
fn Main() -> void { PrintIndexed(["a", "b"]) }
---
PrintIndexed.body.0.type = TForStmt
PrintIndexed.body.0.binder.i.kind = borrowed
PrintIndexed.body.0.binder.s.kind = borrowed
---

=== match case binding borrowed
interface Shape {}
struct Circle : Shape { radius: int }
struct Rect : Shape { w: int h: int }
fn Area(s: Shape) -> int {
    match s {
        case c: Circle {
            return c.radius * c.radius
        }
        case r: Rect {
            return r.w * r.h
        }
    }
}
fn Main() -> void { WritelnOut(ToString(Area(Circle(radius: 5)))) }
---
Area.body.0.type = TMatchStmt
Area.body.0.cases.0.pattern.kind = borrowed
Area.body.0.cases.1.pattern.kind = borrowed
---

=== catch binding borrowed
fn Foo(s: string) -> int {
    try {
        return ParseInt(s, 10)
    } catch e: ValueError {
        WritelnOut(e.message)
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo("42"))) }
---
Foo.body.0.type = TTryStmt
Foo.body.0.catches.0.kind = borrowed
---

=== method self borrowed
struct Counter {
    n: int
    fn Get(self) -> int {
        return self.n
    }
}
fn Main() -> void {
    let c: Counter = Counter(n: 42)
    WritelnOut(ToString(c.Get()))
}
---
Counter.Get.params.self.kind = borrowed
---

=== method constructs and returns owned
struct Pt {
    x: int
    y: int
    fn Offset(self, dx: int, dy: int) -> Pt {
        return Pt(x: self.x + dx, y: self.y + dy)
    }
}
fn Main() -> void {
    let p: Pt = Pt(x: 1, y: 2)
    let q: Pt = p.Offset(10, 20)
    WritelnOut(ToString(q.x))
}
---
Main.lets.q.kind = owned
---

=== builtin return owned Sorted
fn Main() -> void {
    let xs: list[int] = [3, 1, 2]
    let sorted: list[int] = Sorted(xs)
    WritelnOut(ToString(sorted))
}
---
Main.lets.sorted.kind = owned
---

=== builtin return owned Reversed
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    let rev: list[int] = Reversed(xs)
    WritelnOut(ToString(rev))
}
---
Main.lets.rev.kind = owned
---

=== builtin return owned Keys
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    let ks: list[string] = Keys(m)
    WritelnOut(ToString(Len(ks)))
}
---
Main.lets.ks.kind = owned
---

=== builtin return owned Values
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    let vs: list[int] = Values(m)
    WritelnOut(ToString(Len(vs)))
}
---
Main.lets.vs.kind = owned
---

=== builtin return owned Items
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    let items: list[(string, int)] = Items(m)
    WritelnOut(ToString(Len(items)))
}
---
Main.lets.items.kind = owned
---

=== builtin return owned Merge
fn Main() -> void {
    let a: map[string, int] = {"a": 1}
    let b: map[string, int] = {"b": 2}
    let c: map[string, int] = Merge(a, b)
    WritelnOut(ToString(Len(c)))
}
---
Main.lets.c.kind = owned
---

=== builtin return owned Split
fn Main() -> void {
    let parts: list[string] = Split("a,b,c", ",")
    WritelnOut(ToString(Len(parts)))
}
---
Main.lets.parts.kind = owned
---

=== builtin return owned Repeat list
fn Main() -> void {
    let xs: list[int] = Repeat([1], 3)
    WritelnOut(ToString(Len(xs)))
}
---
Main.lets.xs.kind = owned
---

=== string concat owned
fn Main() -> void {
    let s: string = Concat("hello", " world")
    WritelnOut(s)
}
---
Main.lets.s.kind = owned
---

=== reassigned from param to literal shared
struct Pt {
    x: int
    y: int
}
fn Foo(p: Pt) -> Pt {
    let result: Pt = p
    result = Pt(x: 0, y: 0)
    return result
}
fn Main() -> void {
    WritelnOut(ToString(Foo(Pt(x: 1, y: 2)).x))
}
---
Foo.lets.result.kind = shared
---

=== match branches owned and borrowed shared
struct Wrapper {
    items: list[int]
}
fn GetItems(w: Wrapper, flag: int | string) -> list[int] {
    let result: list[int]
    match flag {
        case n: int {
            result = [n]
        }
        case s: string {
            result = w.items
        }
    }
    return result
}
fn Main() -> void {
    let w: Wrapper = Wrapper(items: [1])
    WritelnOut(ToString(Len(GetItems(w, 1))))
}
---
GetItems.lets.result.kind = shared
---

=== try catch owned both paths
fn Parse(s: string) -> list[int] {
    let result: list[int]
    try {
        result = [ParseInt(s, 10)]
    } catch e: ValueError {
        result = []
    }
    return result
}
fn Main() -> void { WritelnOut(ToString(Len(Parse("42")))) }
---
Parse.lets.result.kind = owned
---

=== immutable type still annotated
fn Main() -> void {
    let n: int = 42
    let s: string = "hello"
    let b: bool = true
    WritelnOut(Concat(ToString(n), Concat(s, ToString(b))))
}
---
Main.lets.n.kind = owned
Main.lets.s.kind = owned
Main.lets.b.kind = owned
---

=== tuple owned
fn Main() -> void {
    let pair: (int, string) = (1, "hello")
    WritelnOut(ToString(pair.0))
}
---
Main.lets.pair.kind = owned
---

=== slice expression borrowed
fn Mid(xs: list[int]) -> list[int] {
    let sub: list[int] = xs[1:3]
    return sub
}
fn Main() -> void { WritelnOut(ToString(Len(Mid([1, 2, 3, 4])))) }
---
Mid.lets.sub.kind = borrowed
---

=== return param escapes
fn Identity(xs: list[int]) -> list[int] {
    return xs
}
fn Main() -> void { WritelnOut(ToString(Len(Identity([1])))) }
---
Identity.params.xs.kind = borrowed
Identity.escapes.xs = true
---

=== throw struct escapes
struct AppError {
    message: string
}
fn Fail() -> void {
    let e: AppError = AppError(message: "fail")
    throw e
}
fn Main() -> void {
    try {
        Fail()
    } catch e: AppError {
        WritelnOut(e.message)
    }
}
---
Fail.lets.e.kind = owned
Fail.escapes.e = true
---

=== Insert escapes
fn InsertFirst(xs: list[int], v: int) -> void {
    Insert(xs, 0, v)
}
fn Main() -> void {
    let xs: list[int] = [2, 3]
    InsertFirst(xs, 1)
    WritelnOut(ToString(Len(xs)))
}
---
InsertFirst.escapes.v = true
---

=== local consumed and not returned no escape
fn Process() -> int {
    let xs: list[int] = [1, 2, 3]
    let total: int = 0
    for x in xs {
        total += x
    }
    return total
}
fn Main() -> void { WritelnOut(ToString(Process())) }
---
Process.lets.xs.kind = owned
---

=== Get return borrowed
fn Foo(m: map[string, int]) -> int? {
    let v: int? = Get(m, "key")
    return v
}
fn Main() -> void {
    let m: map[string, int] = {"key": 1}
    WritelnOut(ToString(Foo(m)))
}
---
Foo.lets.v.kind = borrowed
---

=== for binder regions present
fn SumAll(xs: list[int]) -> int {
    let total: int = 0
    for i, x in xs {
        total += i
        total += x
    }
    return total
}
fn Main() -> void { WritelnOut(ToString(SumAll([1, 2, 3]))) }
---
SumAll.body.1.type = TForStmt
SumAll.body.1.binder.i.region = SumAll.body.1.binder.x.region
SumAll.lets.total.region = SumAll.params.xs.region
---

=== match case regions present
interface Shape {}
struct Circle : Shape { radius: int }
struct Rect : Shape { w: int h: int }
fn Area(s: Shape) -> int {
    match s {
        case c: Circle {
            return c.radius * c.radius
        }
        case r: Rect {
            return r.w * r.h
        }
    }
}
fn Main() -> void { WritelnOut(ToString(Area(Circle(radius: 5)))) }
---
Area.body.0.type = TMatchStmt
Area.body.0.cases.0.pattern.region = Area.params.s.region
Area.body.0.cases.1.pattern.region = Area.params.s.region
---

=== match default binding region present
interface Value {}
struct Number : Value { n: int }
struct Text : Value { s: string }
fn Fallback(v: Value) -> int {
    match v {
        case n: Number {
            return n.n
        }
        default rest {
            return Len(ToString(rest))
        }
    }
}
fn Main() -> void { WritelnOut(ToString(Fallback(Text(s: "x")))) }
---
Fallback.body.0.type = TMatchStmt
Fallback.body.0.default.kind = borrowed
Fallback.body.0.default.region = Fallback.params.v.region
---

=== typed catch binding region present
fn ParseOrZero(s: string) -> int {
    try {
        return ParseInt(s, 10)
    } catch e: ValueError {
        WritelnErr(e.message)
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(ParseOrZero("42"))) }
---
ParseOrZero.body.0.type = TTryStmt
ParseOrZero.body.0.catches.0.kind = borrowed
ParseOrZero.body.0.catches.0.region = ParseOrZero.params.s.region
---

=== catch-all binding region present
fn ParseAnyOrZero(s: string) -> int {
    try {
        return ParseInt(s, 10)
    } catch e {
        WritelnErr(ToString(e))
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(ParseAnyOrZero("42"))) }
---
ParseAnyOrZero.body.0.type = TTryStmt
ParseAnyOrZero.body.0.catches.0.kind = borrowed
ParseAnyOrZero.body.0.catches.0.region = ParseAnyOrZero.params.s.region
---
