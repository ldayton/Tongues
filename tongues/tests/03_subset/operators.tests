=== equality allowed
def f(a: int, b: int) -> bool:
    return a == b
---
ok
---

=== inequality allowed
def f(a: int, b: int) -> bool:
    return a != b
---
ok
---

=== less than allowed
def f(a: int, b: int) -> bool:
    return a < b
---
ok
---

=== less than or equal allowed
def f(a: int, b: int) -> bool:
    return a <= b
---
ok
---

=== greater than allowed
def f(a: int, b: int) -> bool:
    return a > b
---
ok
---

=== greater than or equal allowed
def f(a: int, b: int) -> bool:
    return a >= b
---
ok
---

=== comparison chain allowed
def f(a: int, b: int, c: int) -> bool:
    return a < b < c
---
ok
---

=== three-way comparison chain allowed
def f(a: int, b: int, c: int, d: int) -> bool:
    return a < b <= c < d
---
ok
---

=== in operator allowed
def f(x: int, xs: list[int]) -> bool:
    return x in xs
---
ok
---

=== not in operator allowed
def f(x: int, xs: list[int]) -> bool:
    return x not in xs
---
ok
---

=== in with string allowed
def f(s: str, t: str) -> bool:
    return s in t
---
ok
---

=== in with dict allowed
def f(k: str, d: dict[str, int]) -> bool:
    return k in d
---
ok
---

=== in with set allowed
def f(x: int, s: set[int]) -> bool:
    return x in s
---
ok
---

=== is None allowed
def f(x: int | None) -> bool:
    return x is None
---
ok
---

=== is not None allowed
def f(x: int | None) -> bool:
    return x is not None
---
ok
---

=== is with non-None not allowed
def f(a: object, b: object) -> bool:
    return a is b
---
error: is
---

=== is not with non-None not allowed
def f(a: object, b: object) -> bool:
    return a is not b
---
error: is
---

=== is with literal not allowed
def f(x: int) -> bool:
    return x is 0
---
error: is
---

=== is True allowed
def f(x: bool) -> bool:
    return x is True
---
ok
---

=== is False allowed
def f(x: bool) -> bool:
    return x is False
---
ok
---

=== is comparing two variables not allowed
class Foo:
    pass
def f(a: Foo, b: Foo) -> bool:
    return a is b
---
error: is
---

=== del statement not allowed
def f() -> None:
    x: int = 1
    del x
---
error: del
---

=== del from list not allowed
def f(xs: list[int]) -> None:
    del xs[0]
---
error: del
---

=== del from dict not allowed
def f(d: dict[str, int]) -> None:
    del d["key"]
---
error: del
---

=== augmented add allowed
def f(x: int) -> int:
    x += 1
    return x
---
ok
---

=== augmented subtract allowed
def f(x: int) -> int:
    x -= 1
    return x
---
ok
---

=== augmented multiply allowed
def f(x: int) -> int:
    x *= 2
    return x
---
ok
---

=== augmented divide allowed
def f(x: float) -> float:
    x /= 2
    return x
---
ok
---

=== augmented floor divide allowed
def f(x: int) -> int:
    x //= 2
    return x
---
ok
---

=== augmented modulo allowed
def f(x: int) -> int:
    x %= 2
    return x
---
ok
---

=== augmented power allowed
def f(x: int) -> int:
    x **= 2
    return x
---
ok
---

=== augmented bitwise and allowed
def f(x: int) -> int:
    x &= 0xFF
    return x
---
ok
---

=== augmented bitwise or allowed
def f(x: int) -> int:
    x |= 0xFF
    return x
---
ok
---

=== augmented bitwise xor allowed
def f(x: int) -> int:
    x ^= 0xFF
    return x
---
ok
---

=== augmented left shift allowed
def f(x: int) -> int:
    x <<= 1
    return x
---
ok
---

=== augmented right shift allowed
def f(x: int) -> int:
    x >>= 1
    return x
---
ok
---

=== list augmented extend allowed
def f(xs: list[int]) -> list[int]:
    xs += [1, 2, 3]
    return xs
---
ok
---

=== walrus in if allowed
def f() -> int:
    if (x := 1):
        return x
    return 0
---
ok
---

=== walrus in while allowed
def f(xs: list[int]) -> int:
    total: int = 0
    i: int = 0
    while (x := xs[i] if i < len(xs) else 0):
        total += x
        i += 1
    return total
---
ok
---

=== walrus in comprehension condition allowed
def f(xs: list[int]) -> list[int]:
    return [y for x in xs if (y := x * 2) > 0]
---
ok
---

=== walrus in list comprehension allowed
def f(xs: list[str]) -> list[int]:
    return [n for s in xs if (n := len(s)) > 0]
---
ok
---

=== simple f-string allowed
def f(x: int) -> str:
    return f"{x}"
---
ok
---

=== f-string with text allowed
def f(name: str) -> str:
    return f"hello {name}"
---
ok
---

=== f-string with multiple expressions allowed
def f(a: int, b: int) -> str:
    return f"{a} + {b} = {a + b}"
---
ok
---

=== f-string with expression allowed
def f(x: int) -> str:
    return f"{x * 2}"
---
ok
---

=== f-string repr conversion not allowed
def f(x: str) -> str:
    return f"{x!r}"
---
error: conversion
---

=== f-string str conversion not allowed
def f(x: int) -> str:
    return f"{x!s}"
---
error: conversion
---

=== f-string ascii conversion not allowed
def f(x: str) -> str:
    return f"{x!a}"
---
error: conversion
---

=== f-string format spec not allowed
def f(x: float) -> str:
    return f"{x:.2f}"
---
error: format
---

=== f-string width spec not allowed
def f(x: int) -> str:
    return f"{x:10}"
---
error: format
---

=== f-string padding spec not allowed
def f(x: int) -> str:
    return f"{x:010}"
---
error: format
---

=== f-string alignment spec not allowed
def f(x: str) -> str:
    return f"{x:<10}"
---
error: format
---

=== nested f-string allowed
def f(x: int) -> str:
    return f"value: {f'{x}'}"
---
ok
---

=== arithmetic operators allowed
def f(a: int, b: int) -> int:
    return a + b - a * b // a % b
---
ok
---

=== power operator allowed
def f(a: int, b: int) -> int:
    return a ** b
---
ok
---

=== unary minus allowed
def f(x: int) -> int:
    return -x
---
ok
---

=== unary plus allowed
def f(x: int) -> int:
    return +x
---
ok
---

=== unary not allowed
def f(x: bool) -> bool:
    return not x
---
ok
---

=== bitwise not allowed
def f(x: int) -> int:
    return ~x
---
ok
---

=== bitwise and allowed
def f(a: int, b: int) -> int:
    return a & b
---
ok
---

=== bitwise or allowed
def f(a: int, b: int) -> int:
    return a | b
---
ok
---

=== bitwise xor allowed
def f(a: int, b: int) -> int:
    return a ^ b
---
ok
---

=== left shift allowed
def f(a: int, b: int) -> int:
    return a << b
---
ok
---

=== right shift allowed
def f(a: int, b: int) -> int:
    return a >> b
---
ok
---

=== logical and allowed
def f(a: bool, b: bool) -> bool:
    return a and b
---
ok
---

=== logical or allowed
def f(a: bool, b: bool) -> bool:
    return a or b
---
ok
---

=== conditional expression allowed
def f(cond: bool, a: int, b: int) -> int:
    return a if cond else b
---
ok
---

=== string concatenation allowed
def f(a: str, b: str) -> str:
    return a + b
---
ok
---

=== string repetition allowed
def f(s: str, n: int) -> str:
    return s * n
---
ok
---

=== list concatenation allowed
def f(a: list[int], b: list[int]) -> list[int]:
    return a + b
---
ok
---

=== indexing allowed
def f(xs: list[int]) -> int:
    return xs[0]
---
ok
---

=== negative indexing allowed
def f(xs: list[int]) -> int:
    return xs[-1]
---
ok
---

=== slicing allowed
def f(xs: list[int]) -> list[int]:
    return xs[1:3]
---
ok
---

=== slice with step allowed
def f(xs: list[int]) -> list[int]:
    return xs[::2]
---
ok
---

=== attribute access allowed
class Foo:
    def __init__(self) -> None:
        self.x: int = 0
def f(foo: Foo) -> int:
    return foo.x
---
ok
---

=== method call allowed
def f(xs: list[int]) -> None:
    xs.append(1)
---
ok
---

=== chained method calls allowed
def f(s: str) -> str:
    return s.strip().lower()
---
ok
---

=== surrogate code point in string not allowed
def f() -> str:
    return "\ud800"
---
error: surrogate
---
