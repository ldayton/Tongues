=== return type mismatch
fn Foo() -> int {
    return "hello"
}
fn Main() -> void {
}
---
error: cannot return
---

=== return value from void function
fn Foo() -> void {
    return 42
}
fn Main() -> void {
}
---
error: cannot return value
---

=== missing return value
fn Foo() -> int {
    return
}
fn Main() -> void {
}
---
error: missing return value
---

=== bare return in void function
fn Foo() -> void {
    return
}
fn Main() -> void {
}
---
ok
---

=== if condition must be bool
fn Main() -> void {
    if 42 {
    }
}
---
error:
---

=== while condition must be bool
fn Main() -> void {
    while 42 {
    }
}
---
error:
---

=== break outside loop
fn Main() -> void {
    break
}
---
error: break outside of loop
---

=== continue outside loop
fn Main() -> void {
    continue
}
---
error: continue outside of loop
---

=== break inside loop valid
fn Main() -> void {
    while true {
        break
    }
}
---
ok
---

=== for over list
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    for x in xs {
        WritelnOut(ToString(x))
    }
}
---
ok
---

=== for with two variables over list
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    for i, x in xs {
        WritelnOut(ToString(i))
    }
}
---
ok
---

=== for tuple destructuring over list of tuples
fn Main() -> void {
    let pairs: list[(string, int)] = [("a", 1), ("b", 2)]
    for name, val in pairs {
        WritelnOut(Concat(name, ToString(val)))
    }
}
---
ok
---

=== for over map
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    for k, v in m {
        WritelnOut(k)
    }
}
---
ok
---

=== for over string
fn Main() -> void {
    let s: string = "hello"
    for ch in s {
        WritelnOut(ToString(RuneToInt(ch)))
    }
}
---
ok
---

=== for with range
fn Main() -> void {
    for i in range(10) {
        WritelnOut(ToString(i))
    }
}
---
ok
---

=== for with range start end
fn Main() -> void {
    for i in range(1, 10) {
        WritelnOut(ToString(i))
    }
}
---
ok
---

=== for with range start end step
fn Main() -> void {
    for i in range(0, 10, 2) {
        WritelnOut(ToString(i))
    }
}
---
ok
---

=== assignment type mismatch
fn Main() -> void {
    let x: int = 42
    x = "hello"
}
---
error: cannot assign
---

=== invalid assignment target
fn Main() -> void {
    42 = 10
}
---
error: invalid assignment target
---

=== cannot assign to self
struct Pt {
    x: int
    y: int
    fn Reset(self) -> void {
        self = Pt(0, 0)
    }
}
fn Main() -> void {
}
---
error: cannot assign to self
---

=== compound assignment
fn Main() -> void {
    let x: int = 10
    x += 5
    x -= 3
    x *= 2
}
---
ok
---

=== tuple assignment
fn Pair() -> (int, int) {
    return (1, 2)
}
fn Main() -> void {
    let a: int
    let b: int
    a, b = Pair()
}
---
ok
---

=== try catch basic
fn Main() -> void {
    try {
        let n: int = ParseInt("abc", 10)
    } catch e: ValueError {
        WritelnErr(e.message)
    }
}
---
ok
---

=== try catch finally
fn Main() -> void {
    try {
        let n: int = ParseInt("abc", 10)
    } catch e: ValueError {
        WritelnErr(e.message)
    } finally {
        WritelnOut("done")
    }
}
---
ok
---

=== throw struct
struct MyError {
    message: string
}
fn Main() -> void {
    throw MyError("bad")
}
---
ok
---

=== cannot assign to tuple element
fn Main() -> void {
    let t: (int, string) = (1, "hello")
    t.0 = 2
}
---
error: cannot assign to tuple element
---

=== cannot assign to string index
fn Main() -> void {
    let s: string = "hello"
    s[0] = 'x'
}
---
error:
---
