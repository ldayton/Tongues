=== simple return
fn Foo() -> int {
    return 1
}
fn Main() -> void { WritelnOut(ToString(Foo())) }
---
Foo.always_returns = true
---

=== no return
fn Foo() -> void {
    WritelnOut("hi")
}
fn Main() -> void { Foo() }
---
Foo.always_returns = false
---

=== if else both return
fn Foo(x: int) -> int {
    if x > 0 {
        return 1
    } else {
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo(1))) }
---
Foo.always_returns = true
Foo.body.0.type = TIfStmt
Foo.body.0.always_returns = true
---

=== if no else
fn Foo(x: int) -> int {
    if x > 0 {
        return 1
    }
    return 0
}
fn Main() -> void { WritelnOut(ToString(Foo(1))) }
---
Foo.always_returns = true
Foo.body.0.type = TIfStmt
Foo.body.0.always_returns = false
---

=== while always false
fn Foo() -> void {
    while true {
        return
    }
}
fn Main() -> void { Foo() }
---
Foo.body.0.type = TWhileStmt
Foo.body.0.always_returns = false
---

=== for always false
fn Foo() -> void {
    let xs: list[int] = [1, 2, 3]
    for x in xs {
        return
    }
}
fn Main() -> void { Foo() }
---
Foo.body.1.type = TForStmt
Foo.body.1.always_returns = false
---

=== match all arms return
interface Shape {}
struct Circle : Shape { radius: int }
struct Rect : Shape { w: int h: int }
fn Describe(s: Shape) -> string {
    match s {
        case c: Circle {
            return "circle"
        }
        case r: Rect {
            return "rect"
        }
    }
}
fn Main() -> void { WritelnOut(Describe(Circle(radius: 1))) }
---
Describe.always_returns = true
Describe.body.0.type = TMatchStmt
Describe.body.0.always_returns = true
Describe.body.0.cases.0.always_returns = true
Describe.body.0.cases.1.always_returns = true
---

=== match missing arm
interface Shape {}
struct Circle : Shape { radius: int }
struct Rect : Shape { w: int h: int }
fn Describe(s: Shape) -> string {
    match s {
        case c: Circle {
            return "circle"
        }
        case r: Rect {
            WritelnOut("rect")
        }
    }
    return "unknown"
}
fn Main() -> void { WritelnOut(Describe(Circle(radius: 1))) }
---
Describe.body.0.type = TMatchStmt
Describe.body.0.always_returns = false
---

=== try catch both return
fn Foo(s: string) -> int {
    try {
        return ParseInt(s, 10)
    } catch e: ValueError {
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo("42"))) }
---
Foo.always_returns = true
Foo.body.0.type = TTryStmt
Foo.body.0.always_returns = true
---

=== throw terminator
fn Foo() -> int {
    throw ValueError(message: "nope")
}
fn Main() -> void {
    try {
        WritelnOut(ToString(Foo()))
    } catch e: ValueError {
        WritelnOut("caught")
    }
}
---
Foo.always_returns = true
---

=== exit terminator
fn Foo() -> void {
    Exit(1)
}
fn Main() -> void { Foo() }
---
Foo.always_returns = true
---

=== nested compound
fn Foo(x: int) -> int {
    if x > 0 {
        if x > 10 {
            return 100
        } else {
            return 1
        }
    } else {
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo(5))) }
---
Foo.always_returns = true
---

=== catch body has return
fn Foo(s: string) -> int {
    try {
        return ParseInt(s, 10)
    } catch e: ValueError {
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo("42"))) }
---
Foo.needs_named_returns = true
---

=== no try catch
fn Foo() -> int {
    return 1
}
fn Main() -> void { WritelnOut(ToString(Foo())) }
---
Foo.needs_named_returns = false
---

=== try catch without returns
fn Foo() -> void {
    try {
        WritelnOut("hi")
    } catch e: ValueError {
        WritelnOut("err")
    }
}
fn Main() -> void { Foo() }
---
Foo.needs_named_returns = false
---

=== nested try in if
fn Foo(x: int, s: string) -> int {
    if x > 0 {
        try {
            return ParseInt(s, 10)
        } catch e: ValueError {
            return 0
        }
    }
    return x
}
fn Main() -> void { WritelnOut(ToString(Foo(1, "42"))) }
---
Foo.needs_named_returns = true
---

=== return nil
fn Foo() -> int? {
    return nil
}
fn Main() -> void {
    let x: int? = Foo()
    WritelnOut(ToString(0))
}
---
Foo.may_return_nil = true
---

=== return optional var no narrowing
fn Foo(x: int?) -> int? {
    return x
}
fn Main() -> void {
    let r: int? = Foo(nil)
    WritelnOut(ToString(0))
}
---
Foo.may_return_nil = true
---

=== return narrowed var
fn Foo(x: int?) -> int {
    if x != nil {
        return x
    }
    return 0
}
fn Main() -> void { WritelnOut(ToString(Foo(1))) }
---
Foo.may_return_nil = false
---

=== return int literal
fn Foo() -> int {
    return 42
}
fn Main() -> void { WritelnOut(ToString(Foo())) }
---
Foo.may_return_nil = false
---

=== return call with optional return
fn MaybeNil() -> int? {
    return nil
}
fn Foo() -> int? {
    return MaybeNil()
}
fn Main() -> void {
    let r: int? = Foo()
    WritelnOut(ToString(0))
}
---
Foo.may_return_nil = true
---

=== bare return
fn Foo() -> void {
    return
}
fn Main() -> void { Foo() }
---
Foo.may_return_nil = false
---

=== return in try body
fn Foo(s: string) -> int {
    try {
        return ParseInt(s, 10)
    } catch e: ValueError {
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo("42"))) }
---
Foo.body.0.type = TTryStmt
Foo.body.0.body_has_return = true
---

=== no return in try body
fn Foo() -> void {
    try {
        WritelnOut("hi")
    } catch e: ValueError {
        WritelnOut("err")
    }
}
fn Main() -> void { Foo() }
---
Foo.body.0.type = TTryStmt
Foo.body.0.body_has_return = false
---

=== nested return in if inside try
fn Foo(x: int, s: string) -> int {
    try {
        if x > 0 {
            return ParseInt(s, 10)
        }
    } catch e: ValueError {
        WritelnOut("err")
    }
    return 0
}
fn Main() -> void { WritelnOut(ToString(Foo(1, "42"))) }
---
Foo.body.0.type = TTryStmt
Foo.body.0.body_has_return = true
---

=== method annotations
struct Calc {
    value: int
    fn Get(self) -> int {
        return self.value
    }
}
fn Main() -> void {
    let c: Calc = Calc(value: 42)
    WritelnOut(ToString(c.Get()))
}
---
Calc.Get.always_returns = true
Calc.Get.needs_named_returns = false
Calc.Get.may_return_nil = false
---

=== match with default all return
interface Shape {}
struct Circle : Shape { radius: int }
struct Rect : Shape { w: int h: int }
fn Describe(s: Shape) -> string {
    match s {
        case c: Circle {
            return "circle"
        }
        default {
            return "other"
        }
    }
}
fn Main() -> void { WritelnOut(Describe(Circle(radius: 1))) }
---
Describe.always_returns = true
Describe.body.0.type = TMatchStmt
Describe.body.0.always_returns = true
Describe.body.0.default.always_returns = true
---

=== catch always returns
fn Foo(s: string) -> int {
    try {
        return ParseInt(s, 10)
    } catch e: ValueError {
        return 0
    }
}
fn Main() -> void { WritelnOut(ToString(Foo("42"))) }
---
Foo.body.0.type = TTryStmt
Foo.body.0.catches.0.always_returns = true
---

=== void explicit return
fn Greet() -> void {
    WritelnOut("hi")
    return
}
fn Main() -> void { Greet() }
---
Greet.always_returns = true
---

=== if else one branch returns
fn Half(x: int) -> int {
    let result: int = 0
    if x > 0 {
        return x / 2
    } else {
        result = 0
    }
    return result
}
fn Main() -> void { WritelnOut(ToString(Half(4))) }
---
Half.body.1.type = TIfStmt
Half.body.1.always_returns = false
---

=== else if chain all return
fn Classify(x: int) -> string {
    if x > 0 {
        return "positive"
    } else if x == 0 {
        return "zero"
    } else {
        return "negative"
    }
}
fn Main() -> void { WritelnOut(Classify(1)) }
---
Classify.always_returns = true
Classify.body.0.type = TIfStmt
Classify.body.0.always_returns = true
---

=== unreachable after return
fn Early(x: int) -> int {
    return x
    WritelnOut("unreachable")
}
fn Main() -> void { WritelnOut(ToString(Early(1))) }
---
Early.always_returns = true
---

=== optional match all return
fn SafeUnwrap(x: int?) -> int {
    match x {
        case v: int {
            return v
        }
        case nil {
            return 0
        }
    }
}
fn Main() -> void { WritelnOut(ToString(SafeUnwrap(5))) }
---
SafeUnwrap.always_returns = true
SafeUnwrap.may_return_nil = false
---

=== try catch only catch returns
fn Parse(s: string) -> int {
    let result: int = 0
    try {
        result = ParseInt(s, 10)
    } catch e: ValueError {
        return -1
    }
    return result
}
fn Main() -> void { WritelnOut(ToString(Parse("42"))) }
---
Parse.needs_named_returns = true
Parse.body.1.type = TTryStmt
Parse.body.1.body_has_return = false
---

=== multiple catches
fn Multi(s: string) -> int {
    try {
        let n: int = ParseInt(s, 10)
        let xs: list[int] = [1, 2, 3]
        return xs[n]
    } catch e: ValueError {
        return -1
    } catch e: IndexError {
        return -2
    }
}
fn Main() -> void { WritelnOut(ToString(Multi("1"))) }
---
Multi.always_returns = true
Multi.needs_named_returns = true
Multi.body.0.type = TTryStmt
Multi.body.0.body_has_return = true
Multi.body.0.always_returns = true
---

=== try with finally no returns
fn WithFinally(s: string) -> int {
    let result: int = 0
    try {
        result = ParseInt(s, 10)
    } catch e: ValueError {
        result = -1
    } finally {
        WritelnOut("done")
    }
    return result
}
fn Main() -> void { WritelnOut(ToString(WithFinally("5"))) }
---
WithFinally.needs_named_returns = false
WithFinally.body.1.type = TTryStmt
WithFinally.body.1.body_has_return = false
---

=== try finally return in catch
fn Cleanup(s: string) -> int {
    try {
        return ParseInt(s, 10)
    } catch e: ValueError {
        return 0
    } finally {
        WritelnOut("cleanup")
    }
}
fn Main() -> void { WritelnOut(ToString(Cleanup("5"))) }
---
Cleanup.needs_named_returns = true
Cleanup.body.0.type = TTryStmt
Cleanup.body.0.body_has_return = true
---

=== may return nil one branch nil
fn MaybeNil(x: int?) -> int? {
    let result: int? = nil
    if x != nil {
        result = x
    }
    return result
}
fn Main() -> void { WritelnOut(ToString(MaybeNil(5))) }
---
MaybeNil.may_return_nil = true
---
