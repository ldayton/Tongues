-- tuple literals and element access
fn TestTupleLiterals() -> void {
    let pair: (int, string) = (1, "hello")
    Assert(pair.0 == 1)
    Assert(pair.1 == "hello")
}

-- triple
fn TestTriple() -> void {
    let t: (int, float, bool) = (42, 3.14, true)
    Assert(t.0 == 42)
    Assert(t.1 == 3.14)
    Assert(t.2)
}

-- tuple zero value
fn TestTupleZeroValue() -> void {
    let t: (int, string)
    Assert(t.0 == 0)
    Assert(t.1 == "")

    let t2: (bool, float, int)
    Assert(!t2.0)
    Assert(t2.1 == 0.0)
    Assert(t2.2 == 0)
}

-- tuple assignment (destructuring)
fn TestTupleDestructuring() -> void {
    let a: int
    let b: int
    a, b = DivMod(17, 5)
    Assert(a == 3)
    Assert(b == 2)
}

-- destructuring from a tuple expression
fn TestTupleDestructuringExpr() -> void {
    let x: int
    let y: string
    x, y = (42, "hello")
    Assert(x == 42)
    Assert(y == "hello")
}

-- tuple equality (deep structural)
fn TestTupleEquality() -> void {
    Assert((1, "a") == (1, "a"))
    Assert((1, "a") != (1, "b"))
    Assert((1, "a") != (2, "a"))
    Assert((1, 2, 3) == (1, 2, 3))
    Assert((1, 2, 3) != (1, 2, 4))
}

-- nested tuples
fn TestNestedTuples() -> void {
    let t: ((int, int), string) = ((1, 2), "hello")
    Assert(t.0.0 == 1)
    Assert(t.0.1 == 2)
    Assert(t.1 == "hello")
}

-- tuple with collection elements
fn TestTupleWithCollections() -> void {
    let t: (list[int], string) = ([1, 2, 3], "abc")
    Assert(Len(t.0) == 3)
    Assert(t.0[0] == 1)
    Assert(t.1 == "abc")
}

-- tuple returned from function
fn MakePair(a: int, b: string) -> (int, string) {
    return (a, b)
}

fn TestTupleReturn() -> void {
    let p: (int, string) = MakePair(42, "hello")
    Assert(p.0 == 42)
    Assert(p.1 == "hello")
}

-- tuple as function parameter
fn SumPair(p: (int, int)) -> int {
    return p.0 + p.1
}

fn TestTupleParam() -> void {
    Assert(SumPair((3, 4)) == 7)
    Assert(SumPair((0, 0)) == 0)
}

-- tuple in a list
fn TestTupleInList() -> void {
    let pairs: list[(int, string)] = [(1, "a"), (2, "b"), (3, "c")]
    Assert(Len(pairs) == 3)
    Assert(pairs[0].0 == 1)
    Assert(pairs[0].1 == "a")
    Assert(pairs[2].0 == 3)
}

-- tuple as map key
fn TestTupleAsMapKey() -> void {
    let m: map[(int, int), string] = {(0, 0): "origin", (1, 0): "right"}
    Assert(m[(0, 0)] == "origin")
    Assert(m[(1, 0)] == "right")
    Assert(Contains(m, (0, 0)))
    Assert(!Contains(m, (0, 1)))
}

fn Main() -> void {
    TestTupleLiterals()
    TestTriple()
    TestTupleZeroValue()
    TestTupleDestructuring()
    TestTupleDestructuringExpr()
    TestTupleEquality()
    TestNestedTuples()
    TestTupleWithCollections()
    TestTupleReturn()
    TestTupleParam()
    TestTupleInList()
    TestTupleAsMapKey()
}
