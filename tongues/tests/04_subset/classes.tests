=== simple class allowed
class Foo:
    pass
---
ok
---

=== class with init allowed
class Foo:
    def __init__(self) -> None:
        self.x: int = 0
---
ok
---

=== class with methods allowed
class Foo:
    def __init__(self) -> None:
        self.x: int = 0
    def get_x(self) -> int:
        return self.x
---
ok
---

=== single inheritance allowed
class Base:
    pass
class Child(Base):
    pass
---
ok
---

=== deep inheritance allowed
class A:
    pass
class B(A):
    pass
class C(B):
    pass
---
ok
---

=== inherit from object allowed
class Foo(object):
    pass
---
ok
---

=== class with super allowed
class Base:
    def __init__(self) -> None:
        self.x: int = 0
class Child(Base):
    def __init__(self) -> None:
        super().__init__()
        self.y: int = 0
---
ok
---

=== method calling other method allowed
class Foo:
    def __init__(self) -> None:
        self.x: int = 0
    def get_x(self) -> int:
        return self.x
    def get_x_doubled(self) -> int:
        return self.get_x() * 2
---
ok
---

=== dataclass allowed
from dataclasses import dataclass
@dataclass
class Point:
    x: int
    y: int
---
ok
---

=== dataclass with default allowed
from dataclasses import dataclass
@dataclass
class Point:
    x: int = 0
    y: int = 0
---
ok
---

=== dataclass eq allowed
from dataclasses import dataclass
@dataclass(eq=True)
class Point:
    x: int
    y: int
---
ok
---

=== dataclass unsafe_hash allowed
from dataclasses import dataclass
@dataclass(unsafe_hash=True)
class Point:
    x: int
    y: int
---
ok
---

=== dataclass kw_only allowed
from dataclasses import dataclass
@dataclass(kw_only=True)
class Point:
    x: int
    y: int
---
ok
---

=== __init__ allowed
class Foo:
    def __init__(self) -> None:
        pass
---
ok
---

=== __new__ allowed
class Foo:
    def __new__(cls: type) -> "Foo":
        return object.__new__(cls)
---
ok
---

=== __repr__ allowed
class Foo:
    def __repr__(self) -> str:
        return "Foo()"
---
ok
---

=== exception multiple inheritance allowed
class MyError(ValueError, Exception):
    pass
---
ok
---

=== exception as second base allowed
class Base:
    pass
class MyError(Base, Exception):
    pass
---
ok
---

=== multiple inheritance not allowed
class A:
    pass
class B:
    pass
class C(A, B):
    pass
---
error: multiple inheritance
---

=== nested class not allowed
class Outer:
    class Inner:
        pass
---
error: nested class
---

=== dataclass frozen not allowed
from dataclasses import dataclass
@dataclass(frozen=True)
class Point:
    x: int
    y: int
---
error: @dataclass
---

=== dataclass order not allowed
from dataclasses import dataclass
@dataclass(order=True)
class Point:
    x: int
    y: int
---
error: @dataclass
---

=== dataclass field default_factory not allowed
from dataclasses import dataclass, field
@dataclass
class Container:
    items: list[int] = field(default_factory=list)
---
error: field
---

=== staticmethod not allowed
class Foo:
    @staticmethod
    def bar() -> int:
        return 1
---
error: staticmethod
---

=== classmethod not allowed
class Foo:
    @classmethod
    def bar(cls: type) -> int:
        return 1
---
error: classmethod
---

=== property not allowed
class Foo:
    def __init__(self) -> None:
        self._x: int = 0
    @property
    def x(self) -> int:
        return self._x
---
error: property
---

=== arbitrary decorator not allowed
def my_decorator(cls: type) -> type:
    return cls
@my_decorator
class Foo:
    pass
---
error: decorator
---

=== __str__ not allowed
class Foo:
    def __str__(self) -> str:
        return "Foo"
---
error: __str__
---

=== __eq__ not allowed
class Foo:
    def __eq__(self, other: object) -> bool:
        return True
---
error: __eq__
---

=== __hash__ not allowed
class Foo:
    def __hash__(self) -> int:
        return 0
---
error: __hash__
---

=== __len__ not allowed
class Foo:
    def __len__(self) -> int:
        return 0
---
error: __len__
---

=== __getitem__ not allowed
class Foo:
    def __getitem__(self, key: int) -> int:
        return 0
---
error: __getitem__
---

=== __setitem__ not allowed
class Foo:
    def __setitem__(self, key: int, value: int) -> None:
        pass
---
error: __setitem__
---

=== __delitem__ not allowed
class Foo:
    def __delitem__(self, key: int) -> None:
        pass
---
error: __delitem__
---

=== __contains__ not allowed
class Foo:
    def __contains__(self, item: int) -> bool:
        return False
---
error: __contains__
---

=== __iter__ not allowed
class Foo:
    def __iter__(self) -> object:
        return self
---
error: __iter__
---

=== __next__ not allowed
class Foo:
    def __next__(self) -> int:
        return 0
---
error: __next__
---

=== __add__ not allowed
class Foo:
    def __add__(self, other: "Foo") -> "Foo":
        return self
---
error: __add__
---

=== __sub__ not allowed
class Foo:
    def __sub__(self, other: "Foo") -> "Foo":
        return self
---
error: __sub__
---

=== __mul__ not allowed
class Foo:
    def __mul__(self, other: int) -> "Foo":
        return self
---
error: __mul__
---

=== __lt__ not allowed
class Foo:
    def __lt__(self, other: "Foo") -> bool:
        return False
---
error: __lt__
---

=== __le__ not allowed
class Foo:
    def __le__(self, other: "Foo") -> bool:
        return False
---
error: __le__
---

=== __gt__ not allowed
class Foo:
    def __gt__(self, other: "Foo") -> bool:
        return False
---
error: __gt__
---

=== __ge__ not allowed
class Foo:
    def __ge__(self, other: "Foo") -> bool:
        return False
---
error: __ge__
---

=== __call__ not allowed
class Foo:
    def __call__(self) -> int:
        return 0
---
error: __call__
---

=== __enter__ not allowed
class Foo:
    def __enter__(self) -> "Foo":
        return self
---
error: __enter__
---

=== __exit__ not allowed
class Foo:
    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> bool:
        return False
---
error: __exit__
---

=== __bool__ not allowed
class Foo:
    def __bool__(self) -> bool:
        return True
---
error: __bool__
---
