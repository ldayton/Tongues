@@["strict_math"]

-- Strict math focuses on cross-target consistency:
-- - int is exactly int64 and overflows trap
-- - shifts >= 64 trap
-- - Min/Max propagate NaN
-- - float % with zero divisor traps
-- - Sorted with NaN traps

fn TestIntAddOverflowTraps() -> void {
    let max: int = 9223372036854775807
    let caught: bool = false
    try {
        let x: int = max + 1
    } catch e {
        caught = true
    }
    Assert(caught, "expected int overflow trap for max + 1")
}

fn TestIntSubOverflowTraps() -> void {
    let max: int = 9223372036854775807
    let min: int = 0 - max - 1
    let caught: bool = false
    try {
        let x: int = min - 1
    } catch e {
        caught = true
    }
    Assert(caught, "expected int overflow trap for min - 1")
}

fn TestIntMulOverflowTraps() -> void {
    let max: int = 9223372036854775807
    let halfUp: int = (max / 2) + 1
    let caught: bool = false
    try {
        let x: int = halfUp * 2
    } catch e {
        caught = true
    }
    Assert(caught, "expected int overflow trap for ((max/2)+1)*2")
}

fn TestIntNegateMinTraps() -> void {
    let max: int = 9223372036854775807
    let min: int = 0 - max - 1
    let caught: bool = false
    try {
        let x: int = -min
    } catch e {
        caught = true
    }
    Assert(caught, "expected int overflow trap for -INT64_MIN")
}

fn TestIntShiftGE64Traps() -> void {
    let caught: bool = false
    try {
        let x: int = 1 << 64
    } catch e {
        caught = true
    }
    Assert(caught, "expected shift trap for 1<<64")

    caught = false
    try {
        let x: int = 1 >> 64
    } catch e {
        caught = true
    }
    Assert(caught, "expected shift trap for 1>>64")
}

fn TestIntPowNegativeExponentTraps() -> void {
    let caught: bool = false
    try {
        let x: int = Pow(2, -1)
    } catch e {
        caught = true
    }
    Assert(caught, "expected Pow(int,int) trap for negative exponent")
}

fn TestIntPowOverflowTraps() -> void {
    let caught: bool = false
    try {
        let x: int = Pow(2, 63)
    } catch e {
        caught = true
    }
    Assert(caught, "expected Pow(int,int) trap on overflow")
}

fn TestMinMaxNaNPropagates() -> void {
    let nan: float = 0.0 / 0.0
    Assert(IsNaN(Min(nan, 1.0)))
    Assert(IsNaN(Min(1.0, nan)))
    Assert(IsNaN(Max(nan, 1.0)))
    Assert(IsNaN(Max(1.0, nan)))
}

fn TestFloatModByZeroTraps() -> void {
    let caught: bool = false
    try {
        let x: float = 1.0 % 0.0
    } catch e {
        caught = true
    }
    Assert(caught, "expected float % 0.0 trap")

    caught = false
    try {
        let x: float = 0.0 % 0.0
    } catch e {
        caught = true
    }
    Assert(caught, "expected float % 0.0 trap for 0.0 % 0.0")
}

fn TestSortedNaNTraps() -> void {
    let nan: float = 0.0 / 0.0
    let caught: bool = false
    try {
        let xs: list[float] = Sorted([1.0, nan, 2.0])
    } catch e {
        caught = true
    }
    Assert(caught, "expected Sorted(list[float]) trap when list contains NaN")
}

fn TestLogicalRightShift() -> void {
    -- positive numbers: same as >>
    Assert(8 >>> 2 == 2, "8 >>> 2 == 2")
    Assert(255 >>> 4 == 15, "255 >>> 4 == 15")

    -- zero shift is identity
    Assert(42 >>> 0 == 42, "42 >>> 0 == 42")

    -- negative numbers: differs from >> by zero-filling from left
    let neg: int = 0 - 1
    let result: int = neg >>> 1
    Assert(result > 0, "(-1) >>> 1 should be positive (zero-filled)")
    Assert(result == 9223372036854775807, "(-1) >>> 1 == INT64_MAX")

    -- shift by 63: only sign bit matters
    let min: int = 0 - 9223372036854775807 - 1
    Assert(min >>> 63 == 1, "INT64_MIN >>> 63 == 1")
    Assert(1 >>> 63 == 0, "1 >>> 63 == 0")
}

fn TestLogicalRightShiftGE64Traps() -> void {
    let caught: bool = false
    try {
        let x: int = 1 >>> 64
    } catch e {
        caught = true
    }
    Assert(caught, "expected shift trap for 1>>>64")

    caught = false
    try {
        let x: int = 1 >>> 100
    } catch e {
        caught = true
    }
    Assert(caught, "expected shift trap for 1>>>100")
}

fn TestWrappingAdd() -> void {
    -- normal case: no overflow
    Assert(WrappingAdd(1, 2) == 3, "WrappingAdd(1, 2) == 3")

    -- overflow: max + 1 wraps to min
    let max: int = 9223372036854775807
    let min: int = 0 - max - 1
    Assert(WrappingAdd(max, 1) == min, "WrappingAdd(max, 1) == min")

    -- overflow: max + max wraps to -2
    Assert(WrappingAdd(max, max) == 0 - 2, "WrappingAdd(max, max) == -2")

    -- zero identity
    Assert(WrappingAdd(42, 0) == 42, "WrappingAdd(42, 0) == 42")
}

fn TestWrappingSub() -> void {
    -- normal case: no underflow
    Assert(WrappingSub(5, 3) == 2, "WrappingSub(5, 3) == 2")

    -- underflow: min - 1 wraps to max
    let max: int = 9223372036854775807
    let min: int = 0 - max - 1
    Assert(WrappingSub(min, 1) == max, "WrappingSub(min, 1) == max")

    -- zero identity
    Assert(WrappingSub(42, 0) == 42, "WrappingSub(42, 0) == 42")
}

fn TestWrappingMul() -> void {
    -- normal case: no overflow
    Assert(WrappingMul(3, 7) == 21, "WrappingMul(3, 7) == 21")

    -- overflow: large * 2 wraps
    let max: int = 9223372036854775807
    let min: int = 0 - max - 1
    Assert(WrappingMul(max, 2) == 0 - 2, "WrappingMul(max, 2) == -2")

    -- zero absorbs
    Assert(WrappingMul(max, 0) == 0, "WrappingMul(max, 0) == 0")

    -- min * -1 wraps back to min (since |min| > max)
    Assert(WrappingMul(min, 0 - 1) == min, "WrappingMul(min, -1) == min")
}

fn Main() -> void {
    TestIntAddOverflowTraps()
    TestIntSubOverflowTraps()
    TestIntMulOverflowTraps()
    TestIntNegateMinTraps()
    TestIntShiftGE64Traps()
    TestIntPowNegativeExponentTraps()
    TestIntPowOverflowTraps()
    TestMinMaxNaNPropagates()
    TestFloatModByZeroTraps()
    TestSortedNaNTraps()
    TestLogicalRightShift()
    TestLogicalRightShiftGE64Traps()
    TestWrappingAdd()
    TestWrappingSub()
    TestWrappingMul()
}

