=== match default binds scrutinee value
fn Show(value: int | string | bool) -> string {
    match value {
        case n: int {
            return ToString(n)
        }
        default x {
            return ToString(x)
        }
    }
}
fn Main() -> void {
    WritelnOut(Show(1))
}
--- perl
if (looks_like_number($value)) {
    my $n = $value;
    return ("" . $n);
} else {
    my $x = $value;
    return ("" . $x);
}
---

=== delete on map is missing-key safe
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    Delete(m, "k")
}
--- perl
delete $m->{"k"};
---

=== unused catch variable is omitted
fn Main() -> void {
    try {
        ParseInt("x", 10)
    } catch e: ValueError {
        WritelnOut("bad")
    }
}
--- perl
if (ref($__err1) eq 'ValueError') {
    say("bad");
}
---

=== used catch variable is kept
fn Main() -> void {
    try {
        ParseInt("x", 10)
    } catch e: ValueError {
        WritelnOut(e.message)
    }
}
--- perl
if (ref($__err1) eq 'ValueError') {
    my $e = $__err1;
    say($e->{message});
}
---

=== unused tuple target becomes underscore
fn Main() -> void {
    let q: int
    let r: int
    q, r = DivMod(17, 5)
    WritelnOut(ToString(q))
}
--- perl
($q, undef) = (int(17 / 5), 17 % 5);
---

=== all tuple targets used
fn Main() -> void {
    let q: int
    let r: int
    q, r = DivMod(17, 5)
    WritelnOut(ToString(q + r))
}
--- perl
($q, $r) = (int(17 / 5), 17 % 5);
---

=== unused match binding is omitted
fn Show(value: int | string) -> string {
    match value {
        case n: int {
            return "int"
        }
        case s: string {
            return s
        }
    }
}
fn Main() -> void {
    WritelnOut(Show(1))
}
--- perl
if (looks_like_number($value)) {
    return "int";
} else {
    my $s = $value;
    return $s;
}
---

=== initial value suppressed when overwritten
fn Main() -> void {
    let x: int = 0
    x = ParseInt(ReadAll(), 10)
    WritelnOut(ToString(x))
}
--- perl
$x = do { my $__s = do { local $/; scalar(<STDIN>) }; my $__b = 10; $__b == 10 ? int($__s) : $__b == 16 ? hex($__s) : $__b == 8 ? oct($__s) : $__b == 2 ? oct('0b' . $__s) : int($__s) };
say(("" . $x));
---

=== initial value kept when read before overwrite
fn Main() -> void {
    let x: int = 0
    WritelnOut(ToString(x))
    x = 1
    WritelnOut(ToString(x))
}
--- perl
my $x = 0;
---

=== in operator emits pythonic form
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    if Contains(xs, 2) {
        WritelnOut("found")
    }
}
--- perl
if (do { my $__f = 0; for (@{$xs}) { if ($_ == 2) { $__f = 1; last; } } $__f }) {
    say("found");
}
---

=== not in operator
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    if !Contains(xs, 2) {
        WritelnOut("missing")
    }
}
--- perl
if (!do { my $__f = 0; for (@{$xs}) { if ($_ == 2) { $__f = 1; last; } } $__f }) {
    say("missing");
}
---

=== not in operator (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    if !@["provenance" = "not_in_operator"] Contains(xs, 2) {
        WritelnOut("missing")
    }
}
--- perl
if (!(do { my $__f = 0; for (@{$xs}) { if ($_ == 2) { $__f = 1; last; } } $__f })) {
    say("missing");
}
---

=== string multiply via Repeat
fn Main() -> void {
    let s: string = Repeat("ab", 3)
    WritelnOut(s)
}
--- perl
my $s = ("ab" x 3);
---

=== list multiply via Repeat
fn Main() -> void {
    let xs: list[int] = Repeat([0], 5)
    WritelnOut(ToString(Len(xs)))
}
--- perl
my $xs = do { my $__r = []; for (1 .. 5) { push(@{$__r}, @{[0]}); } $__r };
say(("" . scalar(@{$xs})));
---

=== negative index via Len subtraction
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    WritelnOut(ToString(xs[Len(xs) - 1]))
}
--- perl
say(("" . $xs->[scalar(@{$xs}) - 1]));
---

=== negative index via Len subtraction (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    WritelnOut(ToString(@["provenance" = "negative_index"] xs[Len(xs) - 1]))
}
--- perl
say(("" . $xs->[-1]));
---

=== open-end slice
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4]
    let tail: list[int] = xs[1:Len(xs)]
    WritelnOut(ToString(Len(tail)))
}
--- perl
my $tail = [ @{$xs}[1 .. (scalar(@{$xs})) - 1] ];
---

=== open-end slice (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4]
    let tail: list[int] = @["provenance" = "open_end"] xs[1:Len(xs)]
    WritelnOut(ToString(Len(tail)))
}
--- perl
my $tail = [ @{$xs}[1 .. $#{$xs}] ];
say(("" . scalar(@{$tail})));
---

=== open-start slice
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4]
    let head: list[int] = xs[0:3]
    WritelnOut(ToString(Len(head)))
}
--- perl
my $head = [ @{$xs}[0 .. (3) - 1] ];
---

=== open-start slice (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4]
    let head: list[int] = @["provenance" = "open_start"] xs[0:3]
    WritelnOut(ToString(Len(head)))
}
--- perl
my $head = [ @{$xs}[0 .. (3) - 1] ];
say(("" . scalar(@{$head})));
---

=== truthiness check on list
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    if Len(xs) > 0 {
        WritelnOut("nonempty")
    }
}
--- perl
if (scalar(@{$xs}) > 0) {
    say("nonempty");
}
---

=== truthiness check on list (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    @["provenance" = "truthiness"] if Len(xs) > 0 {
        WritelnOut("nonempty")
    }
}
--- perl
if (@{$xs}) {
    say("nonempty");
}
---

=== truthiness check on string
fn Main() -> void {
    let s: string = "hello"
    if s != "" {
        WritelnOut(s)
    }
}
--- perl
if ($s ne "") {
    say($s);
}
---

=== truthiness check on string (raised)
fn Main() -> void {
    let s: string = "hello"
    @["provenance" = "truthiness"] if s != "" {
        WritelnOut(s)
    }
}
--- perl
if ($s) {
    say($s);
}
---

=== chained comparison
fn InRange(x: int) -> bool {
    return 0 <= x && x <= 255
}
fn Main() -> void {
    WritelnOut(ToString(InRange(42)))
}
--- perl
sub in_range {
    my ($x) = @_;
    return 0 <= $x && $x <= 255;
}
---

=== chained comparison (raised)
fn InRange(x: int) -> bool {
    return @["provenance" = "chained_comparison"] (0 <= x && x <= 255)
}
fn Main() -> void {
    WritelnOut(ToString(InRange(42)))
}
--- perl
sub in_range {
    my ($x) = @_;
    return 0 <= $x && $x <= 255;
}
---

=== list comprehension
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    let doubled: list[int]
    for x in xs {
        Append(doubled, x * 2)
    }
    WritelnOut(ToString(Len(doubled)))
}
--- perl
for my $x (@{$xs}) {
    push(@{$doubled}, $x * 2);
}
---

=== list comprehension (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    let doubled: list[int]
    @["provenance" = "list_comprehension"] for x in xs {
        Append(doubled, x * 2)
    }
    WritelnOut(ToString(Len(doubled)))
}
--- perl
my $doubled = [map { $_ * 2 } @{$xs}];
say(("" . scalar(@{$doubled})));
---

=== list comprehension with filter
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4, 5]
    let evens: list[int]
    for x in xs {
        if x % 2 == 0 {
            Append(evens, x)
        }
    }
    WritelnOut(ToString(Len(evens)))
}
--- perl
for my $x (@{$xs}) {
    if ($x % 2 == 0) {
        push(@{$evens}, $x);
    }
}
---

=== list comprehension with filter (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4, 5]
    let evens: list[int]
    @["provenance" = "list_comprehension"] for x in xs {
        if x % 2 == 0 {
            Append(evens, x)
        }
    }
    WritelnOut(ToString(Len(evens)))
}
--- perl
my $evens = [grep { $_ % 2 == 0 } @{$xs}];
say(("" . scalar(@{$evens})));
---

=== dict comprehension
fn Main() -> void {
    let keys: list[string] = ["a", "b", "c"]
    let m: map[string, int]
    for i, k in keys {
        m[k] = i
    }
    WritelnOut(ToString(Len(m)))
}
--- perl
for my $i (0 .. $#{$keys}) {
    my $k = $keys->[$i];
    $m->{$k} = $i;
}
---

=== dict comprehension (raised)
fn Main() -> void {
    let keys: list[string] = ["a", "b", "c"]
    let m: map[string, int]
    @["provenance" = "dict_comprehension"] for i, k in keys {
        m[k] = i
    }
    WritelnOut(ToString(Len(m)))
}
--- perl
my $m = do {
    my $__m = {};
    for my $i (0 .. $#{$keys}) { my $k = $keys->[$i]; $__m->{$k} = $i; }
    $__m;
};
---

=== set comprehension
fn Main() -> void {
    let xs: list[int] = [1, 2, 2, 3]
    let unique: set[int]
    for x in xs {
        Add(unique, x)
    }
    WritelnOut(ToString(Len(unique)))
}
--- perl
for my $x (@{$xs}) {
    $unique->{$x} = 1;
}
---

=== set comprehension (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 2, 3]
    let unique: set[int]
    @["provenance" = "set_comprehension"] for x in xs {
        Add(unique, x)
    }
    WritelnOut(ToString(Len(unique)))
}
--- perl
my $unique = do { my $__s = {}; $__s->{$_} = 1 for @{$xs}; $__s };
say(("" . scalar(keys %{$unique})));
---

=== enumerate over list
fn Main() -> void {
    let xs: list[string] = ["a", "b", "c"]
    for i, v in xs {
        WritelnOut(Format("{}: {}", ToString(i), v))
    }
}
--- perl
for my $i (0 .. $#{$xs}) {
    my $v = $xs->[$i];
    say(sprintf("%s: %s", ("" . $i), $v));
}
---

=== format string becomes f-string
fn Greet(name: string) -> string {
    return Format("hello, {}", name)
}
fn Main() -> void {
    WritelnOut(Greet("world"))
}
--- perl
return sprintf("hello, %s", $name);
---

=== match on optional with nil case
fn Describe(x: int?) -> string {
    match x {
        case v: int {
            return ToString(v)
        }
        case nil {
            return "absent"
        }
    }
}
fn Main() -> void {
    WritelnOut(Describe(nil))
}
--- perl
if (defined($x)) {
    my $v = $x;
    return ("" . $v);
} else {
    return "absent";
}
---

=== match on enum
enum Color {
    Red
    Green
    Blue
}
fn Name(c: Color) -> string {
    match c {
        case Color.Red {
            return "red"
        }
        case Color.Green {
            return "green"
        }
        case Color.Blue {
            return "blue"
        }
    }
}
fn Main() -> void {
    WritelnOut(Name(Color.Red))
}
--- perl
if ($c == Color::Red) {
    return "red";
} elsif ($c == Color::Green) {
    return "green";
} else {
    return "blue";
}
---

=== match on interface
interface Shape {}
struct Circle : Shape {
    radius: float
}
struct Rect : Shape {
    w: float
    h: float
}
fn Area(s: Shape) -> float {
    match s {
        case c: Circle {
            return 3.14159 * c.radius * c.radius
        }
        case r: Rect {
            return r.w * r.h
        }
    }
}
fn Main() -> void {
    WritelnOut(ToString(Area(Circle(1.0))))
}
--- perl
if (eval { $s->isa('Circle') }) {
    my $c = $s;
    return 3.14159 * $c->{radius} * $c->{radius};
} else {
    my $r = $s;
    return $r->{w} * $r->{h};
}
---

=== nil narrowing after check
fn Safe(x: int?) -> int {
    if x != nil {
        return x + 1
    }
    return 0
}
fn Main() -> void {
    WritelnOut(ToString(Safe(5)))
}
--- perl
if (defined($x)) {
    return $x + 1;
}
---

=== nil check with early return
fn MustGet(x: int?) -> int {
    if x == nil {
        return 0
    }
    return Unwrap(x) * 2
}
fn Main() -> void {
    WritelnOut(ToString(MustGet(nil)))
}
--- perl
if (!defined($x)) {
    return 0;
}
return $x * 2;
---

=== struct construction and field access
struct Point {
    x: int
    y: int
}
fn Main() -> void {
    let p: Point = Point(1, 2)
    WritelnOut(ToString(p.x + p.y))
}
--- perl
my $p = Point->new(1, 2);
---

=== struct method call
struct Counter {
    n: int

    fn Inc(self) -> void {
        self.n += 1
    }

    fn Value(self) -> int {
        return self.n
    }
}
fn Main() -> void {
    let c: Counter = Counter(0)
    c.Inc()
    WritelnOut(ToString(c.Value()))
}
--- perl
my $c = Counter->new(0);
$c->inc();
say(("" . $c->value()));
---

=== while loop
fn Main() -> void {
    let n: int = 10
    let total: int = 0
    while n > 0 {
        total += n
        n -= 1
    }
    WritelnOut(ToString(total))
}
--- perl
while ($n > 0) {
    $total += $n;
    $n -= 1;
}
---

=== for range single arg
fn Main() -> void {
    let total: int = 0
    for i in range(10) {
        total += i
    }
    WritelnOut(ToString(total))
}
--- perl
my $__start0 = 0;
my $__end0 = 10;
for (my $i = $__start0; $i < $__end0; $i += 1) {
    $total += $i;
}
---

=== for range two args
fn Main() -> void {
    let total: int = 0
    for i in range(5, 10) {
        total += i
    }
    WritelnOut(ToString(total))
}
--- perl
my $__start0 = 5;
my $__end0 = 10;
for (my $i = $__start0; $i < $__end0; $i += 1) {
    $total += $i;
}
---

=== for range three args
fn Main() -> void {
    for i in range(10, 0, -1) {
        WritelnOut(ToString(i))
    }
}
--- perl
my $__start0 = 10;
my $__end0 = 0;
my $__step0 = -1;
for (my $i = $__start0; $i > $__end0; $i += $__step0) {
    say(("" . $i));
}
---

=== for over list single var
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    for x in xs {
        WritelnOut(ToString(x))
    }
}
--- perl
for my $x (@{$xs}) {
    say(("" . $x));
}
---

=== for over map keys
fn Main() -> void {
    let m: map[string, int] = {"a": 1, "b": 2}
    for k in m {
        WritelnOut(k)
    }
}
--- perl
for my $k (keys %{$m}) {
    say($k);
}
---

=== for over map key-value pairs
fn Main() -> void {
    let m: map[string, int] = {"a": 1, "b": 2}
    for k, v in m {
        WritelnOut(Format("{}: {}", k, ToString(v)))
    }
}
--- perl
for my $k (keys %{$m}) {
    my $v = $m->{$k};
    say(sprintf("%s: %s", $k, ("" . $v)));
}
---

=== break and continue
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4, 5]
    for x in xs {
        if x == 3 {
            continue
        }
        if x == 5 {
            break
        }
        WritelnOut(ToString(x))
    }
}
--- perl
if ($x == 3) {
    next;
}
if ($x == 5) {
    last;
}
---

=== try with finally
fn Main() -> void {
    try {
        WritelnOut("try")
    } catch e: ValueError {
        WritelnOut("catch")
    } finally {
        WritelnOut("finally")
    }
}
--- perl
if (!$__ok0) {
    my $__err1 = $@;
    if (ref($__err1) eq 'ValueError') {
        say("catch");
    }
}
say("finally");
---

=== try with multiple catch clauses
fn Main() -> void {
    try {
        let n: int = ParseInt("x", 10)
        WritelnOut(ToString(n))
    } catch e: ValueError {
        WritelnOut("value error")
    } catch e: KeyError {
        WritelnOut("key error")
    }
}
--- perl
if (ref($__err1) eq 'ValueError') {
    say("value error");
} elsif (ref($__err1) eq 'KeyError') {
    say("key error");
}
---

=== ternary expression
fn Clamp(x: int, lo: int, hi: int) -> int {
    return x < lo ? lo : (x > hi ? hi : x)
}
fn Main() -> void {
    WritelnOut(ToString(Clamp(5, 0, 10)))
}
--- perl
return ($x < $lo ? $lo : ($x > $hi ? $hi : $x));
---

=== Append on list
fn Main() -> void {
    let xs: list[int] = [1, 2]
    Append(xs, 3)
    WritelnOut(ToString(Len(xs)))
}
--- perl
push(@{$xs}, 3);
---

=== Get with default on map
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    let v: int = Get(m, "b", 0)
    WritelnOut(ToString(v))
}
--- perl
my $v = (exists $m->{"b"} ? $m->{"b"} : 0);
---

=== Get without default returns optional
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    let v: int? = Get(m, "b")
    WritelnOut(ToString(v))
}
--- perl
my $v = $m->{"b"};
---

=== Keys Values Items on map
fn Main() -> void {
    let m: map[string, int] = {"a": 1, "b": 2}
    let ks: list[string] = Keys(m)
    let vs: list[int] = Values(m)
    let ps: list[(string, int)] = Items(m)
    WritelnOut(ToString(Len(ks)))
}
--- perl
my $ks = [keys %{$m}];
my $vs = [values %{$m}];
my $ps = do { my $__m = $m; [map { [$_, $__m->{$_}] } keys %{$__m}] };
---

=== Contains on string
fn Main() -> void {
    let s: string = "hello world"
    if Contains(s, "world") {
        WritelnOut("found")
    }
}
--- perl
if (index($s, "world") >= 0) {
    say("found");
}
---

=== Contains on map
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    if Contains(m, "a") {
        WritelnOut("found")
    }
}
--- perl
if (exists($m->{"a"})) {
    say("found");
}
---

=== IndexOf on list
fn Main() -> void {
    let xs: list[int] = [10, 20, 30]
    let idx: int = IndexOf(xs, 20)
    WritelnOut(ToString(idx))
}
--- perl
my $idx = do {
    my $__i = 0;
    my $__r = -1;
    for my $v (@{$xs}) { if ($v == 20) { $__r = $__i; last; } $__i += 1; }
    $__r;
};
---

=== Split and Join
fn Main() -> void {
    let parts: list[string] = Split("a,b,c", ",")
    let joined: string = Join("-", parts)
    WritelnOut(joined)
}
--- perl
my $parts = do { my $__s = "a,b,c"; my $__sep = ","; [split(/\Q$__sep\E/, $__s)] };
my $joined = join("-", @{$parts});
---

=== string Find
fn Main() -> void {
    let idx: int = Find("hello world", "world")
    WritelnOut(ToString(idx))
}
--- perl
my $idx = index("hello world", "world");
---

=== Replace on string
fn Main() -> void {
    let s: string = Replace("aabbcc", "bb", "XX")
    WritelnOut(s)
}
--- perl
my $s = do { my $__s = "aabbcc"; $__s =~ s/bb/XX/g; $__s };
---

=== Upper and Lower
fn Main() -> void {
    WritelnOut(Upper("hello"))
    WritelnOut(Lower("HELLO"))
}
--- perl
say(uc("hello"));
---

=== StartsWith and EndsWith
fn Main() -> void {
    let s: string = "hello world"
    WritelnOut(ToString(StartsWith(s, "hello")))
    WritelnOut(ToString(EndsWith(s, "world")))
}
--- perl
say(("" . (($s =~ /^\Qhello\E/) ? 1 : 0)));
say(("" . (($s =~ /\Qworld\E$/) ? 1 : 0)));
---

=== Sorted and Reversed
fn Main() -> void {
    let xs: list[int] = [3, 1, 2]
    let s: list[int] = Sorted(xs)
    let r: list[int] = Reversed(xs)
    WritelnOut(ToString(Len(s)))
}
--- perl
my $s = [sort { $a <=> $b } @{$xs}];
my $r = [reverse @{$xs}];
---

=== Pop and RemoveAt
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    let last: int = Pop(xs)
    RemoveAt(xs, 0)
    WritelnOut(ToString(last))
}
--- perl
my $last_ = pop(@{$xs});
splice(@{$xs}, 0, 1);
---

=== Insert on list
fn Main() -> void {
    let xs: list[int] = [1, 3]
    Insert(xs, 1, 2)
    WritelnOut(ToString(Len(xs)))
}
--- perl
splice(@{$xs}, 1, 0, 2);
---

=== Add and Remove on set
fn Main() -> void {
    let s: set[int] = {1, 2, 3}
    Add(s, 4)
    Remove(s, 1)
    WritelnOut(ToString(Len(s)))
}
--- perl
$s->{4} = 1;
delete $s->{1};
---

=== Merge maps
fn Main() -> void {
    let a: map[string, int] = {"x": 1}
    let b: map[string, int] = {"y": 2}
    let c: map[string, int] = Merge(a, b)
    WritelnOut(ToString(Len(c)))
}
--- perl
my $c = { %{$a}, %{$b} };
---

=== Concat strings
fn Main() -> void {
    let s: string = Concat("hello", " world")
    WritelnOut(s)
}
--- perl
my $s = ("hello" . " world");
---

=== Assert with message
fn Main() -> void {
    let x: int = 42
    Assert(x > 0, "must be positive")
}
--- perl
die("must be positive") unless ($x > 0);
---

=== Assert without message
fn Main() -> void {
    let x: int = 42
    Assert(x > 0)
}
--- perl
die("assertion failed") unless ($x > 0);
---

=== Unwrap on optional
fn Main() -> void {
    let x: int? = 42
    let v: int = Unwrap(x)
    WritelnOut(ToString(v))
}
--- perl
my $v = $x;
say(("" . $v));
---

=== function as value
fn Double(x: int) -> int {
    return x * 2
}
fn Apply(f: fn[int, int], x: int) -> int {
    return f(x)
}
fn Main() -> void {
    WritelnOut(ToString(Apply(Double, 5)))
}
--- perl
return $f->($x);
---

=== function literal expression body
fn Apply(f: fn[int, int], x: int) -> int {
    return f(x)
}
fn Main() -> void {
    let result: int = Apply((x: int) -> int => x * 2, 10)
    WritelnOut(ToString(result))
}
--- perl
my $result = apply(sub { my ($x) = @_; return $x * 2; }, 10);
---

=== function literal block body
fn Apply(f: fn[int, void], x: int) -> void {
    f(x)
}
fn Main() -> void {
    Apply((x: int) -> void {
        WritelnOut(ToString(x))
    }, 42)
}
--- perl
apply(sub {
    my ($x) = @_;
    say(("" . $x));
}, 42);
---

=== negated condition
fn Main() -> void {
    let done: bool = false
    if !done {
        WritelnOut("not done")
    }
}
--- perl
if (!$done) {
    say("not done");
}
---

=== bitwise operators
fn Main() -> void {
    let x: int = 255
    let y: int = x & 15
    let z: int = x | 256
    let w: int = x ^ 15
    let s: int = x << 2
    let r: int = x >> 4
    let c: int = ~x
    WritelnOut(ToString(y))
}
--- perl
my $y = $x & 15;
my $z = $x | 256;
my $w = $x ^ 15;
---

=== compound assignment operators
fn Main() -> void {
    let x: int = 10
    x += 5
    x -= 2
    x *= 3
    x /= 2
    x %= 7
    WritelnOut(ToString(x))
}
--- perl
$x += 5;
---

=== conversion functions
fn Main() -> void {
    let f: float = IntToFloat(42)
    let n: int = FloatToInt(3.14)
    let b: byte = IntToByte(65)
    let i: int = ByteToInt(b)
    WritelnOut(ToString(f))
}
--- perl
my $f = 42.0;
my $n = int(3.14);
my $b = chr(65);
my $i = ord($b);
---

=== tuple construction and access
fn Main() -> void {
    let pair: (int, string) = (1, "hello")
    let x: int = pair.0
    let y: string = pair.1
    WritelnOut(Format("{} {}", ToString(x), y))
}
--- perl
my $pair = [1, "hello"];
---

=== map literal and index
fn Main() -> void {
    let m: map[string, int] = {"a": 1, "b": 2}
    let v: int = m["a"]
    m["c"] = 3
    WritelnOut(ToString(v))
}
--- perl
my $m = { "a" => 1, "b" => 2 };
---

=== set literal
fn Main() -> void {
    let s: set[int] = {1, 2, 3}
    WritelnOut(ToString(Len(s)))
}
--- perl
my $s = do { my $__s = {}; $__s->{$_} = 1 for (1, 2, 3); $__s };
---

=== empty map and set via constructors
fn Main() -> void {
    let m: map[string, int] = Map()
    let s: set[int] = Set()
    WritelnOut(ToString(Len(m)))
}
--- perl
my $m = {};
---

=== math functions
fn Main() -> void {
    WritelnOut(ToString(Abs(-5)))
    WritelnOut(ToString(Min(3, 7)))
    WritelnOut(ToString(Max(3, 7)))
    WritelnOut(ToString(Pow(2, 10)))
}
--- perl
say(("" . abs(-5)));
---

=== float math functions
fn Main() -> void {
    let r: int = Round(3.7)
    WritelnOut(ToString(r))
}
--- perl
my $r = int(3.7 + (3.7 >= 0 ? 0.5 : -0.5));
---

=== string classification functions
fn Main() -> void {
    WritelnOut(ToString(IsDigit("123")))
    WritelnOut(ToString(IsAlpha("abc")))
    WritelnOut(ToString(IsAlnum("abc123")))
    WritelnOut(ToString(IsSpace(" ")))
    WritelnOut(ToString(IsUpper("ABC")))
    WritelnOut(ToString(IsLower("abc")))
}
--- perl
say(("" . ("123" =~ /^\d+$/ ? 1 : 0)));
say(("" . ("abc" =~ /^[A-Za-z]+$/ ? 1 : 0)));
---

=== Trim functions
fn Main() -> void {
    let s: string = Trim("  hello  ", " ")
    let s2: string = TrimStart("  hello", " ")
    let s3: string = TrimEnd("hello  ", " ")
    WritelnOut(s)
}
--- perl
my $s = do { my $__t = "  hello  "; $__t =~ s/^[ ]+|[ ]+$//g; $__t };
my $s2 = do { my $__t = "  hello"; $__t =~ s/^[ ]+//; $__t };
my $s3 = do { my $__t = "hello  "; $__t =~ s/[ ]+$//; $__t };
---

=== Count and RFind on string
fn Main() -> void {
    let c: int = Count("abcabc", "abc")
    let r: int = RFind("abcabc", "abc")
    WritelnOut(ToString(c))
}
--- perl
my $c = () = "abcabc" =~ /abc/g;
my $r = rindex("abcabc", "abc");
---

=== SplitN and SplitWhitespace
fn Main() -> void {
    let parts: list[string] = SplitN("a,b,c,d", ",", 2)
    let words: list[string] = SplitWhitespace("  hello   world  ")
    WritelnOut(ToString(Len(parts)))
}
--- perl
my $parts = [split(/\Q,\E/, "a,b,c,d", 2)];
my $words = [grep { length($_) > 0 } split(/\s+/, "  hello   world  ")];
---

=== IO functions
fn Main() -> void {
    WriteOut("no newline")
    WritelnOut("with newline")
    WritelnErr("error")
}
--- perl
print("no newline");
---

=== ReadAll and ReadLine
fn Main() -> void {
    let all: string = ReadAll()
    WritelnOut(all)
}
--- perl
my $all = do { local $/; scalar(<STDIN>) };
---

=== Sum on list
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4, 5]
    WritelnOut(ToString(Sum(xs)))
}
--- perl
say(("" . (sum(@{$xs}) // 0)));
---

=== DivMod
fn Main() -> void {
    let q: int
    let r: int
    q, r = DivMod(17, 5)
    WritelnOut(Format("{} {}", ToString(q), ToString(r)))
}
--- perl
($q, $r) = (int(17 / 5), 17 % 5);
---

=== ParseInt and ParseFloat
fn Main() -> void {
    let n: int = ParseInt("42", 10)
    let f: float = ParseFloat("3.14")
    WritelnOut(ToString(n))
}
--- perl
my $n = do { my $__s = "42"; my $__b = 10; $__b == 10 ? int($__s) : $__b == 16 ? hex($__s) : $__b == 8 ? oct($__s) : $__b == 2 ? oct('0b' . $__s) : int($__s) };
---

=== FormatInt
fn Main() -> void {
    let hex: string = FormatInt(255, 16)
    WritelnOut(hex)
}
--- perl
my $hex = sprintf('%x', 255);
---

=== RuneToInt and RuneFromInt
fn Main() -> void {
    let n: int = RuneToInt('A')
    let c: rune = RuneFromInt(65)
    WritelnOut(ToString(n))
}
--- perl
my $n = ord("A");
---

=== Len on various types
fn Main() -> void {
    WritelnOut(ToString(Len("hello")))
    WritelnOut(ToString(Len([1, 2, 3])))
    WritelnOut(ToString(Len({"a": 1})))
    WritelnOut(ToString(Len({1, 2})))
}
--- perl
say(("" . length("hello")));
---

=== throw and catch struct
struct AppError {
    message: string
}
fn Fail() -> void {
    throw AppError("boom")
}
fn Main() -> void {
    try {
        Fail()
    } catch e: AppError {
        WritelnOut(e.message)
    }
}
--- perl
if (ref($__err1) eq 'AppError') {
    my $e = $__err1;
    say($e->{message});
}
---

=== catch union of both error types
struct ErrA {
    message: string
}
struct ErrB {
    message: string
}
fn Risky() -> void {
    throw ErrA("a")
}
fn Main() -> void {
    try {
        Risky()
    } catch e: ErrA | ErrB {
        WritelnOut(e.message)
    }
}
--- perl
if (ref($__err1) eq 'ErrA' || ref($__err1) eq 'ErrB') {
    my $e = $__err1;
    say($e->{message});
}
---

=== catch union of types
struct ErrA {
    message: string
}
struct ErrB {
    message: string
}
fn Risky() -> void {
    throw ErrA("a")
}
fn Main() -> void {
    try {
        Risky()
    } catch e: ErrA | ErrB {
        WritelnOut(e.message)
    }
}
--- perl
if (ref($__err1) eq 'ErrA' || ref($__err1) eq 'ErrB') {
    my $e = $__err1;
    say($e->{message});
}
---

=== Exit call
fn Main() -> void {
    Exit(1)
}
--- perl
exit(1);
---

=== Args and GetEnv
fn Main() -> void {
    let args: list[string] = Args()
    let home: string? = GetEnv("HOME")
    WritelnOut(ToString(Len(args)))
}
--- perl
my $args = [@ARGV];
---

=== Encode and Decode
fn Main() -> void {
    let b: bytes = Encode("hello")
    let s: string = Decode(b)
    WritelnOut(s)
}
--- perl
my $b = encode('UTF-8', "hello");
---

=== if-else chain
fn Classify(x: int) -> string {
    if x > 0 {
        return "positive"
    } else if x == 0 {
        return "zero"
    } else {
        return "negative"
    }
}
fn Main() -> void {
    WritelnOut(Classify(5))
}
--- perl
if ($x > 0) {
    return "positive";
} elsif ($x == 0) {
    return "zero";
} else {
    return "negative";
}
---

=== match on union with three types
fn Describe(v: int | string | bool) -> string {
    match v {
        case n: int {
            return Format("int: {}", ToString(n))
        }
        case s: string {
            return Format("str: {}", s)
        }
        case b: bool {
            return Format("bool: {}", ToString(b))
        }
    }
}
fn Main() -> void {
    WritelnOut(Describe(42))
}
--- perl
if (looks_like_number($v)) {
    my $n = $v;
    return sprintf("int: %s", ("" . $n));
} elsif (!ref($v) && !looks_like_number($v)) {
    my $s = $v;
    return sprintf("str: %s", $s);
} else {
    my $b = $v;
    return sprintf("bool: %s", ("" . $b));
}
---

=== match with default no binding
enum Dir {
    North
    South
    East
    West
}
fn IsVertical(d: Dir) -> bool {
    match d {
        case Dir.North {
            return true
        }
        case Dir.South {
            return true
        }
        default {
            return false
        }
    }
}
fn Main() -> void {
    WritelnOut(ToString(IsVertical(Dir.North)))
}
--- perl
if ($d == Dir::North) {
    return 1;
} elsif ($d == Dir::South) {
    return 1;
} else {
    return 0;
}
---

=== field assignment
struct Point {
    x: int
    y: int
}
fn Main() -> void {
    let p: Point = Point(0, 0)
    p.x = 10
    p.y = 20
    WritelnOut(ToString(p.x + p.y))
}
--- perl
$p->{x} = 10;
$p->{y} = 20;
---

=== index assignment on list
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    xs[0] = 99
    WritelnOut(ToString(xs[0]))
}
--- perl
$xs->[0] = 99;
---

=== index assignment on map
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    m["b"] = 2
    WritelnOut(ToString(m["b"]))
}
--- perl
$m->{"b"} = 2;
---

=== list slicing
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4, 5]
    let mid: list[int] = xs[1:4]
    WritelnOut(ToString(Len(mid)))
}
--- perl
my $mid = [ @{$xs}[1 .. (4) - 1] ];
---

=== string indexing and slicing
fn Main() -> void {
    let s: string = "hello"
    let ch: rune = s[0]
    let sub: string = s[1:4]
    WritelnOut(ToString(RuneToInt(ch)))
}
--- perl
my $ch = substr($s, 0, 1);
---

=== boolean operators
fn Main() -> void {
    let a: bool = true
    let b: bool = false
    WritelnOut(ToString(a && b))
    WritelnOut(ToString(a || b))
    WritelnOut(ToString(!a))
}
--- perl
say(("" . ($a && $b)));
say(("" . ($a || $b)));
say(("" . (!$a)));
---

=== nested struct access
struct Inner {
    value: int
}
struct Outer {
    inner: Inner
}
fn Main() -> void {
    let o: Outer = Outer(Inner(42))
    WritelnOut(ToString(o.inner.value))
}
--- perl
say(("" . $o->{inner}->{value}));
---

=== enum comparison
enum Color {
    Red
    Green
    Blue
}
fn Main() -> void {
    let c: Color = Color.Red
    if c == Color.Red {
        WritelnOut("red")
    }
}
--- perl
if ($c == Color::Red) {
    say("red");
}
---

=== struct with interface field
interface Node {}
struct Leaf : Node {
    value: int
}
struct Branch : Node {
    left: Node
    right: Node
}
fn Eval(n: Node) -> int {
    match n {
        case l: Leaf {
            return l.value
        }
        case b: Branch {
            return Eval(b.left) + Eval(b.right)
        }
    }
}
fn Main() -> void {
    let tree: Node = Branch(Leaf(1), Leaf(2))
    WritelnOut(ToString(Eval(tree)))
}
--- perl
return eval($b->{left}) + eval($b->{right});
---

=== IsNaN and IsInf
fn Main() -> void {
    let x: float = 0.0 / 0.0
    let y: float = 1.0 / 0.0
    WritelnOut(ToString(IsNaN(x)))
    WritelnOut(ToString(IsInf(y)))
}
--- perl
say(("" . (($x != $x) ? 1 : 0)));
say(("" . (POSIX::isinf($y) ? 1 : 0)));
---

=== for over string characters
fn Main() -> void {
    for ch in "hello" {
        WritelnOut(ToString(RuneToInt(ch)))
    }
}
--- perl
for my $ch (split(//, "hello")) {
    say(("" . ord($ch)));
}
---

=== for over set
fn Main() -> void {
    let s: set[int] = {1, 2, 3}
    for v in s {
        WritelnOut(ToString(v))
    }
}
--- perl
for my $v (keys %{$s}) {
    say(("" . $v));
}
---

=== Sqrt function
fn Main() -> void {
    let x: float = Sqrt(2.0)
    WritelnOut(ToString(x))
}
--- perl
my $x = sqrt(2.0);
---

=== Floor function
fn Main() -> void {
    let n: int = Floor(3.7)
    WritelnOut(ToString(n))
}
--- perl
my $n = floor(3.7);
---

=== Ceil function
fn Main() -> void {
    let n: int = Ceil(3.2)
    WritelnOut(ToString(n))
}
--- perl
my $n = ceil(3.2);
---

=== Reverse on string
fn Main() -> void {
    let s: string = Reverse("hello")
    WritelnOut(s)
}
--- perl
my $s = scalar(reverse("hello"));
---

=== while true with break
fn Main() -> void {
    let n: int = 0
    while true {
        n += 1
        if n >= 5 {
            break
        }
    }
    WritelnOut(ToString(n))
}
--- perl
while (1) {
---

=== re-throw in catch
fn Main() -> void {
    try {
        ParseInt("x", 10)
    } catch e: ValueError {
        throw e
    }
}
--- perl
die $e;
---

=== catch-all without type
struct AppError {
    message: string
}
fn Fail() -> void {
    throw AppError("boom")
}
fn Main() -> void {
    try {
        Fail()
    } catch e {
        WritelnOut(e.message)
    }
}
--- perl
my $e = $__err1;
say($e->{message});
---

=== catch-all after typed catch
struct ErrA {
    message: string
}
struct ErrB {
    message: string
}
fn Risky(x: int) -> void {
    if x > 0 {
        throw ErrA("a")
    }
    throw ErrB("b")
}
fn Main() -> void {
    try {
        Risky(1)
    } catch e: ErrA {
        WritelnOut("got A")
    } catch e {
        WritelnOut(e.message)
    }
}
--- perl
if (ref($__err1) eq 'ErrA') {
    say("got A");
} else {
    my $e = $__err1;
    say($e->{message});
}
---

=== Sorted on string list
fn Main() -> void {
    let xs: list[string] = ["banana", "apple", "cherry"]
    let s: list[string] = Sorted(xs)
    WritelnOut(ToString(Len(s)))
}
--- perl
my $s = [sort @{$xs}];
---

=== ReadLine returns optional
fn Main() -> void {
    let line: string? = ReadLine()
    if line != nil {
        WritelnOut(Unwrap(line))
    }
}
--- perl
my $line = scalar(<STDIN>);
---

=== ReadFile emits open idiom
fn Main() -> void {
    let data: string | bytes = ReadFile("input.txt")
    WritelnOut(ToString(data))
}
--- perl
my $data = do { my $__p = "input.txt"; open(my $__fh, '<', $__p) or die $__p; local $/; my $__d = <$__fh>; close($__fh); $__d };
---

=== WriteFile emits open idiom
fn Main() -> void {
    WriteFile("output.txt", "hello")
}
--- perl
do { my $__p = "output.txt"; my $__d = "hello"; open(my $__fh, '>', $__p) or die $__p; print $__fh $__d; close($__fh) };
---

=== ReadBytesN
fn Main() -> void {
    let chunk: bytes = ReadBytesN(1024)
    WritelnOut(ToString(Len(chunk)))
}
--- perl
my $chunk = do { read(STDIN, my $__b, 1024); $__b };
---

=== bytes indexing
fn Main() -> void {
    let b: bytes = Encode("hello")
    let first: byte = b[0]
    WritelnOut(ToString(ByteToInt(first)))
}
--- perl
my $first = substr($b, 0, 1);
---

=== bytes slicing
fn Main() -> void {
    let b: bytes = Encode("hello")
    let part: bytes = b[1:3]
    WritelnOut(ToString(Len(part)))
}
--- perl
my $part = substr($b, 1, (3) - (1));
---

=== Concat on bytes
fn Main() -> void {
    let a: bytes = Encode("hello")
    let b: bytes = Encode(" world")
    let c: bytes = Concat(a, b)
    WritelnOut(ToString(Len(c)))
}
--- perl
my $c = ($a . $b);
---

=== nested collection access
fn Main() -> void {
    let m: map[string, list[int]] = {"a": [1, 2, 3]}
    let v: int = m["a"][0]
    WritelnOut(ToString(v))
}
--- perl
my $v = $m->{"a"}->[0];
---

=== named struct construction
struct Point {
    x: int
    y: int
}
fn Main() -> void {
    let p: Point = Point(y: 2, x: 1)
    WritelnOut(ToString(p.x + p.y))
}
--- perl
my $p = Point->new(1, 2);
---

=== truthiness check on map (raised)
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    @["provenance" = "truthiness"] if Len(m) > 0 {
        WritelnOut("nonempty")
    }
}
--- perl
if (%{$m}) {
    say("nonempty");
}
---

=== truthiness check on set (raised)
fn Main() -> void {
    let s: set[int] = {1, 2, 3}
    @["provenance" = "truthiness"] if Len(s) > 0 {
        WritelnOut("nonempty")
    }
}
--- perl
if (%{$s}) {
    say("nonempty");
}
---

=== negated condition (raised)
fn Main() -> void {
    let done: bool = false
    @["provenance" = "negated_condition"] if !done {
        WritelnOut("not done")
    }
}
--- perl
unless ($done) {
    say("not done");
}
---

=== negated while (raised)
fn Main() -> void {
    let n: int = 10
    let done: bool = false
    @["provenance" = "negated_while"] while !done {
        n -= 1
        if n == 0 {
            done = true
        }
    }
    WritelnOut(ToString(n))
}
--- perl
until ($done) {
---

=== format string with interpolation (raised)
fn Greet(name: string) -> string {
    return @["provenance" = "f_string"] Format("hello, {}", name)
}
fn Main() -> void {
    WritelnOut(Greet("world"))
}
--- perl
return "hello, $name";
---

=== nil coalesce (raised)
fn Safe(x: int?) -> int {
    return @["provenance" = "none_coalesce"] (x != nil ? Unwrap(x) : 0)
}
fn Main() -> void {
    WritelnOut(ToString(Safe(nil)))
}
--- perl
return ($x // 0);
---

=== Get with default using defined-or (raised)
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    let v: int = @["provenance" = "dict_get_default"] Get(m, "b", 0)
    WritelnOut(ToString(v))
}
--- perl
my $v = ($m->{"b"} // 0);
---
