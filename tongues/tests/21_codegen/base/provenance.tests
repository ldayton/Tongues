=== not in operator (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    if !@["provenance" = "not_in_operator"] Contains(xs, 2) {
        WritelnOut("missing")
    }
}

=== negative index via Len subtraction (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    WritelnOut(ToString(@["provenance" = "negative_index"] xs[Len(xs) - 1]))
}

=== open-end slice (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4]
    let tail: list[int] = @["provenance" = "open_end"] xs[1:Len(xs)]
    WritelnOut(ToString(Len(tail)))
}

=== open-start slice (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4]
    let head: list[int] = @["provenance" = "open_start"] xs[0:3]
    WritelnOut(ToString(Len(head)))
}

=== truthiness check on list (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    @["provenance" = "truthiness"] if Len(xs) > 0 {
        WritelnOut("nonempty")
    }
}

=== truthiness check on string (raised)
fn Main() -> void {
    let s: string = "hello"
    @["provenance" = "truthiness"] if s != "" {
        WritelnOut(s)
    }
}

=== chained comparison (raised)
fn InRange(x: int) -> bool {
    return @["provenance" = "chained_comparison"] (0 <= x && x <= 255)
}
fn Main() -> void {
    WritelnOut(ToString(InRange(42)))
}

=== list comprehension (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    let doubled: list[int]
    @["provenance" = "list_comprehension"] for x in xs {
        Append(doubled, x * 2)
    }
    WritelnOut(ToString(Len(doubled)))
}

=== list comprehension with filter (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 3, 4, 5]
    let evens: list[int]
    @["provenance" = "list_comprehension"] for x in xs {
        if x % 2 == 0 {
            Append(evens, x)
        }
    }
    WritelnOut(ToString(Len(evens)))
}

=== dict comprehension (raised)
fn Main() -> void {
    let keys: list[string] = ["a", "b", "c"]
    let m: map[string, int]
    @["provenance" = "dict_comprehension"] for i, k in keys {
        m[k] = i
    }
    WritelnOut(ToString(Len(m)))
}

=== set comprehension (raised)
fn Main() -> void {
    let xs: list[int] = [1, 2, 2, 3]
    let unique: set[int]
    @["provenance" = "set_comprehension"] for x in xs {
        Add(unique, x)
    }
    WritelnOut(ToString(Len(unique)))
}

=== truthiness check on map (raised)
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    @["provenance" = "truthiness"] if Len(m) > 0 {
        WritelnOut("nonempty")
    }
}

=== truthiness check on set (raised)
fn Main() -> void {
    let s: set[int] = {1, 2, 3}
    @["provenance" = "truthiness"] if Len(s) > 0 {
        WritelnOut("nonempty")
    }
}

=== negated condition (raised)
fn Main() -> void {
    let done: bool = false
    @["provenance" = "negated_condition"] if !done {
        WritelnOut("not done")
    }
}

=== negated while (raised)
fn Main() -> void {
    let n: int = 10
    let done: bool = false
    @["provenance" = "negated_while"] while !done {
        n -= 1
        if n == 0 {
            done = true
        }
    }
    WritelnOut(ToString(n))
}

=== format string with interpolation (raised)
fn Greet(name: string) -> string {
    return @["provenance" = "f_string"] Format("hello, {}", name)
}
fn Main() -> void {
    WritelnOut(Greet("world"))
}

=== nil coalesce (raised)
fn Safe(x: int?) -> int {
    return @["provenance" = "none_coalesce"] (x != nil ? Unwrap(x) : 0)
}
fn Main() -> void {
    WritelnOut(ToString(Safe(nil)))
}

=== Get with default using defined-or (raised)
fn Main() -> void {
    let m: map[string, int] = {"a": 1}
    let v: int = @["provenance" = "dict_get_default"] Get(m, "b", 0)
    WritelnOut(ToString(v))
}
