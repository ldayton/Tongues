=== let const
fn Main() -> void {
    let x: int = 1
    let y: int = 2
    x = 3
    WritelnOut(ToString(y))
}
---
Main.lets.x.is_reassigned = true
Main.lets.x.is_const = false
Main.lets.y.is_reassigned = false
Main.lets.y.is_const = true
---

=== op assign reassigns
fn Main() -> void {
    let x: int = 1
    x += 2
    WritelnOut(ToString(x))
}
---
Main.lets.x.is_reassigned = true
---

=== field assign not reassign
struct Pt {
    x: int
    y: int
}
fn Main() -> void {
    let p: Pt = Pt(x: 1, y: 2)
    p.x = 3
    WritelnOut(ToString(p.x))
}
---
Main.lets.p.is_reassigned = false
Main.lets.p.is_const = true
---

=== param reassigned
fn Foo(x: int) -> int {
    x = x + 1
    return x
}
fn Main() -> void { WritelnOut(ToString(Foo(1))) }
---
Foo.params.x.is_reassigned = true
Foo.params.x.is_modified = true
---

=== param field mutation
struct Pt {
    x: int
    y: int
}
fn Mutate(p: Pt) -> void {
    p.x = 99
}
fn Main() -> void { Mutate(Pt(x: 1, y: 2)) }
---
Mutate.params.p.is_reassigned = false
Mutate.params.p.is_modified = true
---

=== param mutating builtin
fn Push(xs: list[int]) -> void {
    Append(xs, 1)
}
fn Main() -> void {
    let a: list[int] = [1, 2]
    Push(a)
}
---
Push.params.xs.is_reassigned = false
Push.params.xs.is_modified = true
---

=== param index mutation
fn SetFirst(xs: list[int]) -> void {
    xs[0] = 99
}
fn Main() -> void {
    let a: list[int] = [1, 2]
    SetFirst(a)
}
---
SetFirst.params.xs.is_reassigned = false
SetFirst.params.xs.is_modified = true
---

=== param unused
fn Ignore(x: int) -> int {
    return 0
}
fn Main() -> void { WritelnOut(ToString(Ignore(1))) }
---
Ignore.params.x.is_unused = true
Ignore.params.x.is_modified = false
---

=== param used
fn Identity(x: int) -> int {
    return x
}
fn Main() -> void { WritelnOut(ToString(Identity(1))) }
---
Identity.params.x.is_unused = false
---

=== nil narrowing neq
fn Narrow(x: int?) -> int {
    if x != nil {
        return x
    }
    return 0
}
fn Main() -> void { WritelnOut(ToString(Narrow(1))) }
---
Narrow.vars.x.narrowed_type = int
---

=== nil narrowing eq
fn Narrow(x: int?) -> int {
    if x == nil {
        return 0
    } else {
        return x
    }
}
fn Main() -> void { WritelnOut(ToString(Narrow(1))) }
---
Narrow.vars.x.narrowed_type = int
---

=== match case binding
interface Shape {}
struct Circle : Shape {
    radius: int
}
struct Rect : Shape {
    w: int
    h: int
}
fn Area(s: Shape) -> int {
    match s {
        case c: Circle {
            return c.radius
        }
        case r: Rect {
            return r.w
        }
    }
}
fn Main() -> void {
    WritelnOut(ToString(Area(Circle(radius: 5))))
}
---
Area.body.0.type = TMatchStmt
Area.body.0.cases.0.pattern.is_reassigned = false
Area.body.0.cases.0.pattern.is_const = true
---

=== for binder const
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    for x in xs {
        WritelnOut(ToString(x))
    }
}
---
Main.body.1.type = TForStmt
Main.body.1.binder.x.is_reassigned = false
Main.body.1.binder.x.is_const = true
---

=== for binder reassigned
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    for x in xs {
        x = x + 1
        WritelnOut(ToString(x))
    }
}
---
Main.body.1.type = TForStmt
Main.body.1.binder.x.is_reassigned = true
Main.body.1.binder.x.is_const = false
---

=== for two binders
fn Main() -> void {
    let xs: list[int] = [1, 2, 3]
    for i, x in xs {
        WritelnOut(ToString(i))
        WritelnOut(ToString(x))
    }
}
---
Main.body.1.type = TForStmt
Main.body.1.binder.i.is_const = true
Main.body.1.binder.x.is_const = true
---

=== function ref
fn AddOne(x: int) -> int { return x + 1 }
fn Apply(f: fn[int, int], x: int) -> int { return f(x) }
fn Main() -> void {
    WritelnOut(ToString(Apply(AddOne, 1)))
}
---
Main.vars.AddOne.is_function_ref = true
---

=== function ref as callee
fn Helper() -> void {}
fn Main() -> void {
    Helper()
}
---
Main.vars.Helper.is_function_ref = true
---

=== interface typed
interface Shape {}
struct Circle : Shape {
    radius: int
}
fn Use(s: Shape) -> int {
    match s {
        case c: Circle {
            return c.radius
        }
        default {
            return 0
        }
    }
}
fn Main() -> void {
    WritelnOut(ToString(Use(Circle(radius: 5))))
}
---
Use.vars.s.is_interface = true
---

=== catch binding
fn Main() -> void {
    try {
        WritelnOut("hi")
    } catch e: KeyError {
        WritelnOut(e.message)
    }
}
---
Main.body.0.type = TTryStmt
Main.body.0.catches.0.is_reassigned = false
Main.body.0.catches.0.is_const = true
---

=== void method mutation
struct Counter {
    n: int
    fn Inc(self) -> void {
        self.n = self.n + 1
    }
}
fn Bump(c: Counter) -> void {
    c.Inc()
}
fn Main() -> void {
    let c: Counter = Counter(n: 0)
    Bump(c)
}
---
Bump.params.c.is_modified = true
---

=== tuple assign reassigns
fn Main() -> void {
    let a: int = 1
    let b: int = 2
    a, b = DivMod(10, 3)
    WritelnOut(ToString(a))
}
---
Main.lets.a.is_reassigned = true
Main.lets.b.is_reassigned = true
---
