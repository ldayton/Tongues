-- Tests for CSV table formatter

fn AssertEq(actual: string, expected: string, label: string) -> void {
    if actual != expected {
        throw AssertError(Format("{}: got \"{}\", want \"{}\"", label, actual, expected))
    }
}

fn AssertFields(actual: list[string], expected: list[string], label: string) -> void {
    Assert(Len(actual) == Len(expected),
        Format("{}: got {} fields, want {}", label, ToString(Len(actual)), ToString(Len(expected))))
    for i, field in actual {
        AssertEq(field, expected[i], Format("{}[{}]", label, ToString(i)))
    }
}

fn AssertThrows(threw: bool, label: string) -> void {
    Assert(threw, Format("{}: expected ValueError", label))
}

-- ParseRow tests

fn TestParseRowSimple() -> void {
    let row: list[string] = ParseRow("a,b,c")
    AssertFields(row, ["a", "b", "c"], "simple")
}

fn TestParseRowWhitespace() -> void {
    let row: list[string] = ParseRow("  a , b , c  ")
    AssertFields(row, ["a", "b", "c"], "whitespace")
}

fn TestParseRowQuoted() -> void {
    let row: list[string] = ParseRow("\"hello, world\",b,c")
    AssertFields(row, ["hello, world", "b", "c"], "quoted comma")
}

fn TestParseRowEscapedQuote() -> void {
    let row: list[string] = ParseRow("\"she said \"\"hi\"\"\",b")
    AssertFields(row, ["she said \"hi\"", "b"], "escaped quote")
}

fn TestParseRowSingleField() -> void {
    let row: list[string] = ParseRow("alone")
    AssertFields(row, ["alone"], "single field")
}

fn TestParseRowEmpty() -> void {
    let row: list[string] = ParseRow("a,,c")
    AssertFields(row, ["a", "", "c"], "empty field")
}

fn TestParseRowUnclosedQuote() -> void {
    let threw: bool = false
    try {
        ParseRow("\"oops")
    } catch e: ValueError {
        threw = true
        Assert(Contains(e.message, "unclosed"), "unclosed quote message")
    }
    AssertThrows(threw, "unclosed quote")
}

-- ParseCsv tests

fn TestParseCsvSkipsBlanks() -> void {
    let rows: list[list[string]] = ParseCsv("a,b\n\nc,d\n")
    Assert(Len(rows) == 2, "skip blanks: row count")
    AssertFields(rows[0], ["a", "b"], "skip blanks row 0")
    AssertFields(rows[1], ["c", "d"], "skip blanks row 1")
}

fn TestParseCsvEmpty() -> void {
    let rows: list[list[string]] = ParseCsv("")
    Assert(Len(rows) == 0, "empty input")
}

-- ValidateRows tests

fn TestValidateRowsOk() -> void {
    let rows: list[list[string]] = [["a", "b"], ["c", "d"]]
    let threw: bool = false
    try {
        ValidateRows(rows)
    } catch e: ValueError {
        threw = true
    }
    Assert(!threw, "valid rows should not throw")
}

fn TestValidateRowsRagged() -> void {
    let rows: list[list[string]] = [["a", "b"], ["c"]]
    let threw: bool = false
    try {
        ValidateRows(rows)
    } catch e: ValueError {
        threw = true
        Assert(Contains(e.message, "row 2"), "ragged row message")
    }
    AssertThrows(threw, "ragged rows")
}

-- ComputeWidths tests

fn TestComputeWidths() -> void {
    let rows: list[list[string]] = [["name", "age"], ["alice", "30"], ["bo", "7"]]
    let widths: map[int, int] = ComputeWidths(rows)
    Assert(widths[0] == 5, "col 0 width")
    Assert(widths[1] == 3, "col 1 width")
}

-- Formatting tests

fn TestPadRight() -> void {
    AssertEq(PadRight("hi", 5), "hi   ", "pad right")
    AssertEq(PadRight("hello", 3), "hello", "pad no-op")
    AssertEq(PadRight("", 4), "    ", "pad empty")
}

fn TestSeparator() -> void {
    let widths: map[int, int] = {0: 4, 1: 3}
    AssertEq(Separator(2, widths), "+------+-----+", "separator")
}

fn TestFormatRow() -> void {
    let widths: map[int, int] = {0: 5, 1: 3}
    AssertEq(FormatRow(["name", "age"], widths), "| name  | age |", "format header")
    AssertEq(FormatRow(["bo", "7"], widths), "| bo    | 7   |", "format data row")
}

-- Runner

fn Main() -> void {
    let passed: int = 0
    let failed: int = 0
    let tests: list[fn[void]] = [
        TestParseRowSimple, TestParseRowWhitespace, TestParseRowQuoted,
        TestParseRowEscapedQuote, TestParseRowSingleField, TestParseRowEmpty,
        TestParseRowUnclosedQuote, TestParseCsvSkipsBlanks, TestParseCsvEmpty,
        TestValidateRowsOk, TestValidateRowsRagged, TestComputeWidths,
        TestPadRight, TestSeparator, TestFormatRow
    ]
    let names: list[string] = [
        "ParseRow/simple", "ParseRow/whitespace", "ParseRow/quoted",
        "ParseRow/escaped_quote", "ParseRow/single_field", "ParseRow/empty_field",
        "ParseRow/unclosed_quote", "ParseCsv/skip_blanks", "ParseCsv/empty",
        "ValidateRows/ok", "ValidateRows/ragged", "ComputeWidths",
        "PadRight", "Separator", "FormatRow"
    ]
    for i, test in tests {
        try {
            test()
            WritelnOut(Format("  pass  {}", names[i]))
            passed += 1
        } catch e: obj {
            WritelnErr(Format("  FAIL  {} -- {}", names[i], ToString(e)))
            failed += 1
        }
    }
    WritelnOut(Format("\n{} passed, {} failed", ToString(passed), ToString(failed)))
    if failed > 0 {
        Exit(1)
    }

    -- Demo
    let csv: string = "name,age,city\nalice,30,nyc\nbob,25,\"san francisco\"\ncharlie,35,chicago"
    let rows: list[list[string]] = ParseCsv(csv)
    ValidateRows(rows)
    let widths: map[int, int] = ComputeWidths(rows)
    let ncols: int = Len(rows[0])
    let sep: string = Separator(ncols, widths)
    WritelnOut("")
    WritelnOut(sep)
    WritelnOut(FormatRow(rows[0], widths))
    WritelnOut(sep)
    for i in range(1, Len(rows)) {
        WritelnOut(FormatRow(rows[i], widths))
    }
    WritelnOut(sep)
}

-- Functions under test (single-file language, no imports)

fn ParseCsv(input: string) -> list[list[string]] {
    let lines: list[string] = Split(input, "\n")
    let rows: list[list[string]]
    for line in lines {
        let trimmed: string = Trim(line, " \t\r")
        if trimmed == "" {
            continue
        }
        Append(rows, ParseRow(trimmed))
    }
    return rows
}

fn ParseRow(line: string) -> list[string] {
    let fields: list[string]
    let buf: string = ""
    let quoted: bool = false
    let i: int = 0
    while i < Len(line) {
        let ch: rune = line[i]
        if quoted {
            if ch == '"' {
                if i + 1 < Len(line) && line[i + 1] == '"' {
                    buf = Concat(buf, "\"")
                    i += 2
                    continue
                }
                quoted = false
            } else {
                buf = Concat(buf, ToString(ch))
            }
        } else if ch == '"' {
            quoted = true
        } else if ch == ',' {
            Append(fields, Trim(buf, " "))
            buf = ""
        } else {
            buf = Concat(buf, ToString(ch))
        }
        i += 1
    }
    if quoted {
        throw ValueError("unclosed quote")
    }
    Append(fields, Trim(buf, " "))
    return fields
}

fn ValidateRows(rows: list[list[string]]) -> void {
    let ncols: int = Len(rows[0])
    for i in range(1, Len(rows)) {
        let n: int = Len(rows[i])
        if n != ncols {
            throw ValueError(Format("row {} has {} fields, expected {}",
                ToString(i + 1), ToString(n), ToString(ncols)))
        }
    }
}

fn ComputeWidths(rows: list[list[string]]) -> map[int, int] {
    let widths: map[int, int] = Map()
    for row in rows {
        for c, field in row {
            let prev: int? = Get(widths, c)
            if prev == nil || Len(field) > prev {
                widths[c] = Len(field)
            }
        }
    }
    return widths
}

fn PadRight(s: string, width: int) -> string {
    let gap: int = width - Len(s)
    if gap <= 0 {
        return s
    }
    return Concat(s, Repeat(" ", gap))
}

fn Separator(ncols: int, widths: map[int, int]) -> string {
    let parts: list[string]
    for c in range(ncols) {
        Append(parts, Repeat("-", widths[c] + 2))
    }
    return Concat("+", Concat(Join("+", parts), "+"))
}

fn FormatRow(row: list[string], widths: map[int, int]) -> string {
    let cells: list[string]
    for i, field in row {
        Append(cells, Format(" {} ", PadRight(field, widths[i])))
    }
    return Concat("|", Concat(Join("|", cells), "|"))
}
