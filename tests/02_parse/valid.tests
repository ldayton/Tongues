=== comment line
a #pass
---
ok
---

=== multiply with tab
wblabla* 1
---
ok
---

=== function with annotation
def x(a, b:3): pass
---
ok
---

=== assert statement
assert foo
---
ok
---

=== class definition
class Foo: pass
---
ok
---

=== function definition
def foo(): pass
---
ok
---

=== import statement
import math
---
ok
---

=== if with suite
if foo:
 bar
---
ok
---

=== named expression
(a := 1, a + 1)
---
ok
---

=== extended annassign
x: y = z,
---
ok
---

=== tuple annassign
x: Tuple[int, ...] = z, *q, w
---
ok
---

=== positional only with default
def x(a=1, /): pass
---
ok
---

=== positional only simple
def x(a, /): pass
---
ok
---

=== positional only with keyword default
def x(a=1, /, b=3): pass
---
ok
---

=== positional only with keyword
def x(a, /, b): pass
---
ok
---

=== positional only with kwonly
def x(a, /, *, b): pass
---
ok
---

=== positional only with kwargs
def x(a, /, **kwargs): pass
---
ok
---

=== decorator expression add
@a + a
def x(): pass
---
ok
---

=== decorator lambda
@lambda x: x
def x(): pass
---
ok
---

=== decorator walrus lambda
@a := lambda x: x
def x(): pass
---
ok
---

=== dos line endings
foo = 'ns1!'

---
ok
---

=== for loop simple
for foobar in [1]:
    foobar
---
ok
---

=== empty list
[]
---
ok
---

=== empty dict
{}
---
ok
---

=== empty tuple
()
---
ok
---

=== single element tuple
(1,)
---
ok
---

=== nested function
def outer():
    def inner():
        pass
---
ok
---

=== class with method
class Foo:
    def bar(self):
        pass
---
ok
---

=== try except
try:
    x
except:
    y
---
ok
---

=== try except finally
try:
    x
except:
    y
finally:
    z
---
ok
---

=== with statement
with x:
    y
---
ok
---

=== with as
with x as y:
    z
---
ok
---

=== multiple with
with x, y:
    z
---
ok
---

=== match statement
match x:
    case 1:
        y
---
ok
---

=== match with guard
match x:
    case n if n > 0:
        y
---
ok
---

=== match wildcard
match x:
    case _:
        y
---
ok
---

=== async function
async def foo():
    pass
---
ok
---

=== await expression
async def foo():
    await bar()
---
ok
---

=== async for
async def foo():
    async for x in y:
        pass
---
ok
---

=== async with
async def foo():
    async with x:
        pass
---
ok
---

=== yield expression
def foo():
    yield x
---
ok
---

=== yield from
def foo():
    yield from x
---
ok
---

=== list comprehension
[x for x in y]
---
ok
---

=== nested list comprehension
[x for x in y for z in w]
---
ok
---

=== list comp with if
[x for x in y if z]
---
ok
---

=== dict comprehension
{k: v for k, v in items}
---
ok
---

=== set comprehension
{x for x in y}
---
ok
---

=== generator expression
(x for x in y)
---
ok
---

=== lambda simple
lambda: 1
---
ok
---

=== lambda with args
lambda x, y: x + y
---
ok
---

=== lambda with defaults
lambda x=1: x
---
ok
---

=== lambda with kwargs
lambda **kw: kw
---
ok
---

=== slice simple
x[1:2]
---
ok
---

=== slice step
x[1:2:3]
---
ok
---

=== slice open start
x[:2]
---
ok
---

=== slice open end
x[1:]
---
ok
---

=== slice open both
x[:]
---
ok
---

=== ellipsis
...
---
ok
---

=== ellipsis subscript
x[...]
---
ok
---

=== starred in list
[*x]
---
ok
---

=== starred in tuple
(*x,)
---
ok
---

=== double starred in dict
{**x}
---
ok
---

=== walrus in if
if (x := 1):
    y
---
ok
---

=== walrus in while
while (x := next()):
    y
---
ok
---

=== multiple assignment
a = b = c = 1
---
ok
---

=== augmented assign
x += 1
---
ok
---

=== annotated assign
x: int = 1
---
ok
---

=== annotated no value
x: int
---
ok
---

=== binary operators
a + b - c * d / e // f % g ** h
---
ok
---

=== bitwise operators
a & b | c ^ d << e >> f
---
ok
---

=== comparison chain
a < b <= c == d != e > f >= g
---
ok
---

=== boolean operators
a and b or not c
---
ok
---

=== ternary expression
a if b else c
---
ok
---

=== unary operators
-a + ~b
---
ok
---

=== attribute access
a.b.c
---
ok
---

=== call with args
f(a, b, c)
---
ok
---

=== call with kwargs
f(a=1, b=2)
---
ok
---

=== call with mixed
f(a, b=2, *c, **d)
---
ok
---

=== multiline string
"""
multi
line
"""
---
ok
---

=== raw string
r"\n\t"
---
ok
---

=== bytes literal
b"hello"
---
ok
---

=== unicode string
u"hello"
---
ok
---

=== number literals
123 + 1.5 + 1e10 + 0x1f + 0o17 + 0b101
---
ok
---

=== complex number
1j + 2.5j
---
ok
---

=== underscore in number
1_000_000
---
ok
---

=== global statement
def f():
    global x
---
ok
---

=== nonlocal statement
def f():
    x = 1
    def g():
        nonlocal x
---
ok
---

=== raise simple
raise Exception
---
ok
---

=== raise with message
raise Exception("error")
---
ok
---

=== raise from
raise Exception from cause
---
ok
---

=== bare raise
def f():
    try:
        x
    except:
        raise
---
ok
---

=== except as
try:
    x
except Exception as e:
    y
---
ok
---

=== except tuple
try:
    x
except (A, B):
    y
---
ok
---

=== del statement
del x
---
ok
---

=== del multiple
del x, y, z
---
ok
---

=== del subscript
del x[0]
---
ok
---

=== del attribute
del x.y
---
ok
---

=== pass statement
pass
---
ok
---

=== break statement
for x in y:
    break
---
ok
---

=== continue statement
for x in y:
    continue
---
ok
---

=== return nothing
def f():
    return
---
ok
---

=== return value
def f():
    return 1
---
ok
---

=== class inheritance
class Foo(Bar):
    pass
---
ok
---

=== class multiple inheritance
class Foo(Bar, Baz):
    pass
---
ok
---

=== class with kwargs
class Foo(metaclass=Meta):
    pass
---
ok
---

=== decorator simple
@decorator
def f():
    pass
---
ok
---

=== decorator with args
@decorator(1, 2)
def f():
    pass
---
ok
---

=== multiple decorators
@a
@b
@c
def f():
    pass
---
ok
---

=== type alias
type Alias = int
---
ok
---

=== type alias generic
type Alias[T] = list[T]
---
ok
---

