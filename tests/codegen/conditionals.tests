=== simple ternary
1 if True else 0
---

=== ternary with false
1 if False else 0
---

=== ternary comparison condition
10 if 5 > 3 else 20
---

=== ternary string result
"yes" if True else "no"
---

=== ternary int result
42 if 1 < 2 else 0
---

=== nested ternary else
1 if True else 2 if False else 3
---

=== nested ternary then
(1 if True else 2) if True else 3
--- python
1 if True else 2 if True else 3
---

=== ternary with arithmetic
(1 + 2) if True else (3 + 4)
--- python
1 + 2 if True else 3 + 4
---

=== ternary with variables
def pick(a: int, b: int, use_first: bool) -> int:
    return a if use_first else b
---

=== ternary in expression
1 + (2 if True else 3)
---

=== ternary both sides same type
"a" if True else "b"
---

=== chained comparison in ternary
1 if 1 < 2 < 3 else 0
---

=== ternary with equality
"equal" if 1 == 1 else "not equal"
---

=== ternary with inequality
"different" if 1 != 2 else "same"
---

=== simple if statement
def check(x: int) -> int:
    if x > 0:
        return 1
    return 0
---

=== if else statement
def check(x: int) -> int:
    if x > 0:
        return 1
    else:
        return -1
---

=== if elif else
def classify(x: int) -> str:
    if x > 0:
        return "positive"
    elif x < 0:
        return "negative"
    else:
        return "zero"
---

=== multiple elif
def grade(score: int) -> str:
    if score >= 90:
        return "A"
    elif score >= 80:
        return "B"
    elif score >= 70:
        return "C"
    elif score >= 60:
        return "D"
    else:
        return "F"
---

=== nested if
def nested(x: int, y: int) -> int:
    if x > 0:
        if y > 0:
            return 1
        else:
            return 2
    else:
        return 3
---

=== if with and
def both_positive(x: int, y: int) -> bool:
    if x > 0 and y > 0:
        return True
    return False
---

=== if with not
def is_zero(x: int) -> bool:
    if not (x > 0):
        if not (x < 0):
            return True
    return False
--- python
def is_zero(x: int) -> bool:
    if not x > 0:
        if not x < 0:
            return True
    return False
---

=== if with chained comparison
def in_range(x: int) -> bool:
    if 0 < x < 10:
        return True
    return False
---

=== if modifies variable
def clamp(x: int) -> int:
    result: int = x
    if x < 0:
        result = 0
    elif x > 100:
        result = 100
    return result
---

=== if with break
def find_first_positive(nums: list[int]) -> int:
    i: int = 0
    while i < len(nums):
        if nums[i] > 0:
            return nums[i]
        i = i + 1
    return -1
---

=== if with continue
def count_positive(nums: list[int]) -> int:
    count: int = 0
    i: int = 0
    while i < len(nums):
        if nums[i] <= 0:
            i = i + 1
            continue
        count = count + 1
        i = i + 1
    return count
---

=== ternary assigns to variable
def pick_value(flag: bool) -> int:
    x: int = 10 if flag else 20
    return x
---

=== multiple conditions same block
def multi_check(a: int, b: int, c: int) -> bool:
    if a > 0:
        if b > 0:
            if c > 0:
                return True
    return False
---

=== early return pattern
def validate(x: int) -> bool:
    if x < 0:
        return False
    if x > 100:
        return False
    return True
---

=== guard clause
def process(x: int) -> int:
    if x == 0:
        return 0
    return x * 2
---

=== ternary with min
min(1, 2) if True else 0
---

=== ternary with max
max(1, 2) if True else 0
---

=== ternary float result
1.5 if True else 2.5
---

=== if statement empty else
def maybe_double(x: int, do_it: bool) -> int:
    result: int = x
    if do_it:
        result = x * 2
    return result
---

=== comparison chain in if
def ordered(a: int, b: int, c: int) -> bool:
    if a < b < c:
        return True
    return False
---

=== equality chain
def all_equal(a: int, b: int, c: int) -> bool:
    if a == b == c:
        return True
    return False
---
