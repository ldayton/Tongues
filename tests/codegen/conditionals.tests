=== simple ternary
1 if True else 0
--- javascript
true ? 1 : 0;
--- typescript
true ? 1 : 0;
---

=== ternary with false
1 if False else 0
--- javascript
false ? 1 : 0;
--- typescript
false ? 1 : 0;
---

=== ternary comparison condition
10 if 5 > 3 else 20
--- javascript
5 > 3 ? 10 : 20;
--- typescript
5 > 3 ? 10 : 20;
---

=== ternary string result
"yes" if True else "no"
--- javascript
true ? "yes" : "no";
--- typescript
true ? "yes" : "no";
---

=== ternary int result
42 if 1 < 2 else 0
--- javascript
1 < 2 ? 42 : 0;
--- typescript
1 < 2 ? 42 : 0;
---

=== nested ternary else
1 if True else 2 if False else 3
--- javascript
true ? 1 : false ? 2 : 3;
--- typescript
true ? 1 : false ? 2 : 3;
---

=== nested ternary then
(1 if True else 2) if True else 3
--- python
1 if True else 2 if True else 3
--- javascript
true ? true ? 1 : 2 : 3;
--- typescript
true ? true ? 1 : 2 : 3;
---

=== ternary with arithmetic
(1 + 2) if True else (3 + 4)
--- python
1 + 2 if True else 3 + 4
--- javascript
true ? 1 + 2 : 3 + 4;
--- typescript
true ? 1 + 2 : 3 + 4;
---

=== ternary with variables
def pick(a: int, b: int, use_first: bool) -> int:
    return a if use_first else b
--- javascript
function pick(a, b, useFirst) {
  return useFirst ? a : b;
}
--- typescript
function pick(a: number, b: number, useFirst: boolean): number {
  return useFirst ? a : b;
}
---

=== ternary in expression
1 + (2 if True else 3)
--- javascript
1 + (true ? 2 : 3);
--- typescript
1 + (true ? 2 : 3);
---

=== ternary both sides same type
"a" if True else "b"
--- javascript
true ? "a" : "b";
--- typescript
true ? "a" : "b";
---

=== chained comparison in ternary
1 if 1 < 2 < 3 else 0
--- javascript
1 < 2 && 2 < 3 ? 1 : 0;
--- typescript
1 < 2 && 2 < 3 ? 1 : 0;
---

=== ternary with equality
"equal" if 1 == 1 else "not equal"
--- javascript
1 === 1 ? "equal" : "not equal";
--- typescript
1 === 1 ? "equal" : "not equal";
---

=== ternary with inequality
"different" if 1 != 2 else "same"
--- javascript
1 !== 2 ? "different" : "same";
--- typescript
1 !== 2 ? "different" : "same";
---

=== simple if statement
def check(x: int) -> int:
    if x > 0:
        return 1
    return 0
--- javascript
function check(x) {
  if (x > 0) {
    return 1;
  }
  return 0;
}
--- typescript
function check(x: number): number {
  if (x > 0) {
    return 1;
  }
  return 0;
}
---

=== if else statement
def check(x: int) -> int:
    if x > 0:
        return 1
    else:
        return -1
--- javascript
function check(x) {
  if (x > 0) {
    return 1;
  } else {
    return -1;
  }
}
--- typescript
function check(x: number): number {
  if (x > 0) {
    return 1;
  } else {
    return -1;
  }
}
---

=== if elif else
def classify(x: int) -> str:
    if x > 0:
        return "positive"
    elif x < 0:
        return "negative"
    else:
        return "zero"
--- javascript
function classify(x) {
  if (x > 0) {
    return "positive";
  } else if (x < 0) {
    return "negative";
  } else {
    return "zero";
  }
}
--- typescript
function classify(x: number): string {
  if (x > 0) {
    return "positive";
  } else if (x < 0) {
    return "negative";
  } else {
    return "zero";
  }
}
---

=== multiple elif
def grade(score: int) -> str:
    if score >= 90:
        return "A"
    elif score >= 80:
        return "B"
    elif score >= 70:
        return "C"
    elif score >= 60:
        return "D"
    else:
        return "F"
--- javascript
function grade(score) {
  if (score >= 90) {
    return "A";
  } else if (score >= 80) {
    return "B";
  } else if (score >= 70) {
    return "C";
  } else if (score >= 60) {
    return "D";
  } else {
    return "F";
  }
}
--- typescript
function grade(score: number): string {
  if (score >= 90) {
    return "A";
  } else if (score >= 80) {
    return "B";
  } else if (score >= 70) {
    return "C";
  } else if (score >= 60) {
    return "D";
  } else {
    return "F";
  }
}
---

=== nested if
def nested(x: int, y: int) -> int:
    if x > 0:
        if y > 0:
            return 1
        else:
            return 2
    else:
        return 3
--- javascript
function nested(x, y) {
  if (x > 0) {
    if (y > 0) {
      return 1;
    } else {
      return 2;
    }
  } else {
    return 3;
  }
}
--- typescript
function nested(x: number, y: number): number {
  if (x > 0) {
    if (y > 0) {
      return 1;
    } else {
      return 2;
    }
  } else {
    return 3;
  }
}
---

=== if with and
def both_positive(x: int, y: int) -> bool:
    if x > 0 and y > 0:
        return True
    return False
--- javascript
function bothPositive(x, y) {
  if (x > 0 && y > 0) {
    return true;
  }
  return false;
}
--- typescript
function bothPositive(x: number, y: number): boolean {
  if (x > 0 && y > 0) {
    return true;
  }
  return false;
}
---

=== if with not
def is_zero(x: int) -> bool:
    if not (x > 0):
        if not (x < 0):
            return True
    return False
--- python
def is_zero(x: int) -> bool:
    if not x > 0:
        if not x < 0:
            return True
    return False
--- javascript
function isZero(x) {
  if (!(x > 0)) {
    if (!(x < 0)) {
      return true;
    }
  }
  return false;
}
--- typescript
function isZero(x: number): boolean {
  if (!(x > 0)) {
    if (!(x < 0)) {
      return true;
    }
  }
  return false;
}
---

=== if with chained comparison
def in_range(x: int) -> bool:
    if 0 < x < 10:
        return True
    return False
--- javascript
function inRange(x) {
  if (0 < x && x < 10) {
    return true;
  }
  return false;
}
--- typescript
function inRange(x: number): boolean {
  if (0 < x && x < 10) {
    return true;
  }
  return false;
}
---

=== if modifies variable
def clamp(x: int) -> int:
    result: int = x
    if x < 0:
        result = 0
    elif x > 100:
        result = 100
    return result
--- javascript
function clamp(x) {
  let result = x;
  if (x < 0) {
    result = 0;
  } else if (x > 100) {
    result = 100;
  }
  return result;
}
--- typescript
function clamp(x: number): number {
  let result: number = x;
  if (x < 0) {
    result = 0;
  } else if (x > 100) {
    result = 100;
  }
  return result;
}
---

=== if with break
def find_first_positive(nums: list[int]) -> int:
    i: int = 0
    while i < len(nums):
        if nums[i] > 0:
            return nums[i]
        i = i + 1
    return -1
--- javascript
function findFirstPositive(nums) {
  let i = 0;
  while (i < nums.length) {
    if (nums[i] > 0) {
      return nums[i];
    }
    i = i + 1;
  }
  return -1;
}
--- typescript
function findFirstPositive(nums: number[]): number {
  let i: number = 0;
  while (i < nums.length) {
    if (nums[i] > 0) {
      return nums[i];
    }
    i = i + 1;
  }
  return -1;
}
---

=== if with continue
def count_positive(nums: list[int]) -> int:
    count: int = 0
    i: int = 0
    while i < len(nums):
        if nums[i] <= 0:
            i = i + 1
            continue
        count = count + 1
        i = i + 1
    return count
--- javascript
function countPositive(nums) {
  let count = 0;
  let i = 0;
  while (i < nums.length) {
    if (nums[i] <= 0) {
      i = i + 1;
      continue;
    }
    count = count + 1;
    i = i + 1;
  }
  return count;
}
--- typescript
function countPositive(nums: number[]): number {
  let count: number = 0;
  let i: number = 0;
  while (i < nums.length) {
    if (nums[i] <= 0) {
      i = i + 1;
      continue;
    }
    count = count + 1;
    i = i + 1;
  }
  return count;
}
---

=== ternary assigns to variable
def pick_value(flag: bool) -> int:
    x: int = 10 if flag else 20
    return x
--- javascript
function pickValue(flag) {
  let x = flag ? 10 : 20;
  return x;
}
--- typescript
function pickValue(flag: boolean): number {
  let x: number = flag ? 10 : 20;
  return x;
}
---

=== multiple conditions same block
def multi_check(a: int, b: int, c: int) -> bool:
    if a > 0:
        if b > 0:
            if c > 0:
                return True
    return False
--- javascript
function multiCheck(a, b, c) {
  if (a > 0) {
    if (b > 0) {
      if (c > 0) {
        return true;
      }
    }
  }
  return false;
}
--- typescript
function multiCheck(a: number, b: number, c: number): boolean {
  if (a > 0) {
    if (b > 0) {
      if (c > 0) {
        return true;
      }
    }
  }
  return false;
}
---

=== early return pattern
def validate(x: int) -> bool:
    if x < 0:
        return False
    if x > 100:
        return False
    return True
--- javascript
function validate(x) {
  if (x < 0) {
    return false;
  }
  if (x > 100) {
    return false;
  }
  return true;
}
--- typescript
function validate(x: number): boolean {
  if (x < 0) {
    return false;
  }
  if (x > 100) {
    return false;
  }
  return true;
}
---

=== guard clause
def process(x: int) -> int:
    if x == 0:
        return 0
    return x * 2
--- javascript
function process(x) {
  if (x === 0) {
    return 0;
  }
  return x * 2;
}
--- typescript
function process(x: number): number {
  if (x === 0) {
    return 0;
  }
  return x * 2;
}
---

=== ternary with min
min(1, 2) if True else 0
--- javascript
true ? Math.min(1, 2) : 0;
--- typescript
true ? Math.min(1, 2) : 0;
---

=== ternary with max
max(1, 2) if True else 0
--- javascript
true ? Math.max(1, 2) : 0;
--- typescript
true ? Math.max(1, 2) : 0;
---

=== ternary float result
1.5 if True else 2.5
--- javascript
true ? 1.5 : 2.5;
--- typescript
true ? 1.5 : 2.5;
---

=== if statement empty else
def maybe_double(x: int, do_it: bool) -> int:
    result: int = x
    if do_it:
        result = x * 2
    return result
--- javascript
function maybeDouble(x, doIt) {
  let result = x;
  if (doIt) {
    result = x * 2;
  }
  return result;
}
--- typescript
function maybeDouble(x: number, doIt: boolean): number {
  let result: number = x;
  if (doIt) {
    result = x * 2;
  }
  return result;
}
---

=== comparison chain in if
def ordered(a: int, b: int, c: int) -> bool:
    if a < b < c:
        return True
    return False
--- javascript
function ordered(a, b, c) {
  if (a < b && b < c) {
    return true;
  }
  return false;
}
--- typescript
function ordered(a: number, b: number, c: number): boolean {
  if (a < b && b < c) {
    return true;
  }
  return false;
}
---

=== equality chain
def all_equal(a: int, b: int, c: int) -> bool:
    if a == b == c:
        return True
    return False
--- javascript
function allEqual(a, b, c) {
  if (a === b && b === c) {
    return true;
  }
  return false;
}
--- typescript
function allEqual(a: number, b: number, c: number): boolean {
  if (a === b && b === c) {
    return true;
  }
  return false;
}
---
