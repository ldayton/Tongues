=== simple ternary
1 if True else 0
--- javascript
true ? 1 : 0;
--- typescript
true ? 1 : 0;
--- ruby
true ? 1 : 0
--- lua
(true and 1 or 0)
--- perl
(1 ? 1 : 0);
--- php
true ? 1 : 0;
---

=== ternary with false
1 if False else 0
--- javascript
false ? 1 : 0;
--- typescript
false ? 1 : 0;
--- ruby
false ? 1 : 0
--- lua
(false and 1 or 0)
--- perl
(0 ? 1 : 0);
--- php
false ? 1 : 0;
---

=== ternary comparison condition
10 if 5 > 3 else 20
--- javascript
5 > 3 ? 10 : 20;
--- typescript
5 > 3 ? 10 : 20;
--- ruby
5 > 3 ? 10 : 20
--- lua
(5 > 3 and 10 or 20)
--- perl
(5 > 3 ? 10 : 20);
--- php
5 > 3 ? 10 : 20;
---

=== ternary string result
"yes" if True else "no"
--- javascript
true ? "yes" : "no";
--- typescript
true ? "yes" : "no";
--- ruby
true ? "yes" : "no"
--- lua
(true and "yes" or "no")
--- perl
(1 ? "yes" : "no");
--- php
true ? "yes" : "no";
---

=== ternary int result
42 if 1 < 2 else 0
--- javascript
1 < 2 ? 42 : 0;
--- typescript
1 < 2 ? 42 : 0;
--- ruby
1 < 2 ? 42 : 0
--- lua
(1 < 2 and 42 or 0)
--- perl
(1 < 2 ? 42 : 0);
--- php
1 < 2 ? 42 : 0;
---

=== nested ternary else
1 if True else 2 if False else 3
--- javascript
true ? 1 : false ? 2 : 3;
--- typescript
true ? 1 : false ? 2 : 3;
--- ruby
true ? 1 : false ? 2 : 3
--- lua
(true and 1 or (false and 2 or 3))
--- perl
(1 ? 1 : 0 ? 2 : 3);
--- php
true ? 1 : (false ? 2 : 3);
---

=== nested ternary then
(1 if True else 2) if True else 3
--- python
1 if True else 2 if True else 3
--- javascript
true ? true ? 1 : 2 : 3;
--- typescript
true ? true ? 1 : 2 : 3;
--- ruby
true ? true ? 1 : 2 : 3
--- lua
(true and (true and 1 or 2) or 3)
--- perl
(1 ? (1 ? 1 : 2) : 3);
--- php
true ? true ? 1 : 2 : 3;
---

=== ternary with arithmetic
(1 + 2) if True else (3 + 4)
--- python
1 + 2 if True else 3 + 4
--- javascript
true ? 1 + 2 : 3 + 4;
--- typescript
true ? 1 + 2 : 3 + 4;
--- ruby
true ? 1 + 2 : 3 + 4
--- lua
(true and 1 + 2 or 3 + 4)
--- perl
(1 ? 1 + 2 : 3 + 4);
--- php
true ? 1 + 2 : 3 + 4;
---

=== ternary with variables
def pick(a: int, b: int, use_first: bool) -> int:
    return a if use_first else b
--- javascript
function pick(a, b, useFirst) {
  return useFirst ? a : b;
}
--- typescript
function pick(a: number, b: number, useFirst: boolean): number {
  return useFirst ? a : b;
}
--- ruby
def pick(a, b, use_first)
  use_first ? a : b
end
--- lua
function pick(a, b, use_first)
  return (use_first and a or b)
end
--- perl
sub pick ($a, $b, $use_first) {
    return ($use_first ? $a : $b);
}
--- php
function pick(int $a, int $b, bool $useFirst): int
{
    return $useFirst ? $a : $b;
}
---

=== ternary in expression
1 + (2 if True else 3)
--- javascript
1 + (true ? 2 : 3);
--- typescript
1 + (true ? 2 : 3);
--- ruby
1 + (true ? 2 : 3)
--- lua
1 + (true and 2 or 3)
--- perl
1 + (1 ? 2 : 3);
--- php
1 + (true ? 2 : 3);
---

=== ternary both sides same type
"a" if True else "b"
--- javascript
true ? "a" : "b";
--- typescript
true ? "a" : "b";
--- ruby
true ? "a" : "b"
--- lua
(true and "a" or "b")
--- perl
(1 ? "a" : "b");
--- php
true ? "a" : "b";
---

=== chained comparison in ternary
1 if 1 < 2 < 3 else 0
--- javascript
1 < 2 && 2 < 3 ? 1 : 0;
--- typescript
1 < 2 && 2 < 3 ? 1 : 0;
--- ruby
1 < 2 && 2 < 3 ? 1 : 0
--- lua
(1 < 2 and 2 < 3 and 1 or 0)
--- perl
(1 < 2 && 2 < 3 ? 1 : 0);
--- php
1 < 2 && 2 < 3 ? 1 : 0;
---

=== ternary with equality
"equal" if 1 == 1 else "not equal"
--- javascript
1 === 1 ? "equal" : "not equal";
--- typescript
1 === 1 ? "equal" : "not equal";
--- ruby
1 == 1 ? "equal" : "not equal"
--- lua
(1 == 1 and "equal" or "not equal")
--- perl
(1 == 1 ? "equal" : "not equal");
--- php
1 === 1 ? "equal" : "not equal";
---

=== ternary with inequality
"different" if 1 != 2 else "same"
--- javascript
1 !== 2 ? "different" : "same";
--- typescript
1 !== 2 ? "different" : "same";
--- ruby
1 != 2 ? "different" : "same"
--- lua
(1 ~= 2 and "different" or "same")
--- perl
(1 != 2 ? "different" : "same");
--- php
1 !== 2 ? "different" : "same";
---

=== simple if statement
def check(x: int) -> int:
    if x > 0:
        return 1
    return 0
--- javascript
function check(x) {
  if (x > 0) {
    return 1;
  }
  return 0;
}
--- typescript
function check(x: number): number {
  if (x > 0) {
    return 1;
  }
  return 0;
}
--- ruby
def check(x)
  if x > 0
    return 1
  end
  0
end
--- lua
function check(x)
  if x > 0 then
    return 1
  end
  return 0
end
--- perl
sub check ($x) {
    if ($x > 0) {
        return 1;
    }
    return 0;
}
--- php
function check(int $x): int
{
    if ($x > 0)
    {
        return 1;
    }
    return 0;
}
---

=== if else statement
def check(x: int) -> int:
    if x > 0:
        return 1
    else:
        return -1
--- javascript
function check(x) {
  if (x > 0) {
    return 1;
  } else {
    return -1;
  }
}
--- typescript
function check(x: number): number {
  if (x > 0) {
    return 1;
  } else {
    return -1;
  }
}
--- ruby
def check(x)
  if x > 0
    return 1
  else
    return -1
  end
end
--- lua
function check(x)
  if x > 0 then
    return 1
  else
    return -1
  end
end
--- perl
sub check ($x) {
    if ($x > 0) {
        return 1;
    } else {
        return -1;
    }
}
--- php
function check(int $x): int
{
    if ($x > 0)
    {
        return 1;
    }
    else
    {
        return -1;
    }
}
---

=== if elif else
def classify(x: int) -> str:
    if x > 0:
        return "positive"
    elif x < 0:
        return "negative"
    else:
        return "zero"
--- javascript
function classify(x) {
  if (x > 0) {
    return "positive";
  } else if (x < 0) {
    return "negative";
  } else {
    return "zero";
  }
}
--- typescript
function classify(x: number): string {
  if (x > 0) {
    return "positive";
  } else if (x < 0) {
    return "negative";
  } else {
    return "zero";
  }
}
--- ruby
def classify(x)
  if x > 0
    return "positive"
  elsif x < 0
    return "negative"
  else
    return "zero"
  end
end
--- lua
function classify(x)
  if x > 0 then
    return "positive"
  elseif x < 0 then
    return "negative"
  else
    return "zero"
  end
end
--- perl
sub classify ($x) {
    if ($x > 0) {
        return "positive";
    } elsif ($x < 0) {
        return "negative";
    } else {
        return "zero";
    }
}
--- php
function classify(int $x): string
{
    if ($x > 0)
    {
        return "positive";
    }
    else
    {
        if ($x < 0)
        {
            return "negative";
        }
        else
        {
            return "zero";
        }
    }
}
---

=== multiple elif
def grade(score: int) -> str:
    if score >= 90:
        return "A"
    elif score >= 80:
        return "B"
    elif score >= 70:
        return "C"
    elif score >= 60:
        return "D"
    else:
        return "F"
--- javascript
function grade(score) {
  if (score >= 90) {
    return "A";
  } else if (score >= 80) {
    return "B";
  } else if (score >= 70) {
    return "C";
  } else if (score >= 60) {
    return "D";
  } else {
    return "F";
  }
}
--- typescript
function grade(score: number): string {
  if (score >= 90) {
    return "A";
  } else if (score >= 80) {
    return "B";
  } else if (score >= 70) {
    return "C";
  } else if (score >= 60) {
    return "D";
  } else {
    return "F";
  }
}
--- ruby
def grade(score)
  if score >= 90
    return "A"
  elsif score >= 80
    return "B"
  elsif score >= 70
    return "C"
  elsif score >= 60
    return "D"
  else
    return "F"
  end
end
--- lua
function grade(score)
  if score >= 90 then
    return "A"
  elseif score >= 80 then
    return "B"
  elseif score >= 70 then
    return "C"
  elseif score >= 60 then
    return "D"
  else
    return "F"
  end
end
--- perl
sub grade ($score) {
    if ($score >= 90) {
        return "A";
    } elsif ($score >= 80) {
        return "B";
    } elsif ($score >= 70) {
        return "C";
    } elsif ($score >= 60) {
        return "D";
    } else {
        return "F";
    }
}
--- php
function grade(int $score): string
{
    if ($score >= 90)
    {
        return "A";
    }
    else
    {
        if ($score >= 80)
        {
            return "B";
        }
        else
        {
            if ($score >= 70)
            {
                return "C";
            }
            else
            {
                if ($score >= 60)
                {
                    return "D";
                }
                else
                {
                    return "F";
                }
            }
        }
    }
}
---

=== nested if
def nested(x: int, y: int) -> int:
    if x > 0:
        if y > 0:
            return 1
        else:
            return 2
    else:
        return 3
--- javascript
function nested(x, y) {
  if (x > 0) {
    if (y > 0) {
      return 1;
    } else {
      return 2;
    }
  } else {
    return 3;
  }
}
--- typescript
function nested(x: number, y: number): number {
  if (x > 0) {
    if (y > 0) {
      return 1;
    } else {
      return 2;
    }
  } else {
    return 3;
  }
}
--- ruby
def nested(x, y)
  if x > 0
    if y > 0
      return 1
    else
      return 2
    end
  else
    return 3
  end
end
--- lua
function nested(x, y)
  if x > 0 then
    if y > 0 then
      return 1
    else
      return 2
    end
  else
    return 3
  end
end
--- perl
sub nested ($x, $y) {
    if ($x > 0) {
        if ($y > 0) {
            return 1;
        } else {
            return 2;
        }
    } else {
        return 3;
    }
}
--- php
function nested(int $x, int $y): int
{
    if ($x > 0)
    {
        if ($y > 0)
        {
            return 1;
        }
        else
        {
            return 2;
        }
    }
    else
    {
        return 3;
    }
}
---

=== if with and
def both_positive(x: int, y: int) -> bool:
    if x > 0 and y > 0:
        return True
    return False
--- javascript
function bothPositive(x, y) {
  if (x > 0 && y > 0) {
    return true;
  }
  return false;
}
--- typescript
function bothPositive(x: number, y: number): boolean {
  if (x > 0 && y > 0) {
    return true;
  }
  return false;
}
--- ruby
def both_positive(x, y)
  if x > 0 && y > 0
    return true
  end
  false
end
--- lua
function both_positive(x, y)
  if x > 0 and y > 0 then
    return true
  end
  return false
end
--- perl
sub both_positive ($x, $y) {
    if ($x > 0 && $y > 0) {
        return 1;
    }
    return 0;
}
--- php
function bothPositive(int $x, int $y): bool
{
    if ($x > 0 && $y > 0)
    {
        return true;
    }
    return false;
}
---

=== if with not
def is_zero(x: int) -> bool:
    if not (x > 0):
        if not (x < 0):
            return True
    return False
--- python
def is_zero(x: int) -> bool:
    if not x > 0:
        if not x < 0:
            return True
    return False
--- javascript
function isZero(x) {
  if (!(x > 0)) {
    if (!(x < 0)) {
      return true;
    }
  }
  return false;
}
--- typescript
function isZero(x: number): boolean {
  if (!(x > 0)) {
    if (!(x < 0)) {
      return true;
    }
  }
  return false;
}
--- ruby
def is_zero(x)
  if !(x > 0)
    if !(x < 0)
      return true
    end
  end
  false
end
--- lua
function is_zero(x)
  if not (x > 0) then
    if not (x < 0) then
      return true
    end
  end
  return false
end
--- perl
sub is_zero ($x) {
    if (!($x > 0)) {
        if (!($x < 0)) {
            return 1;
        }
    }
    return 0;
}
--- php
function isZero(int $x): bool
{
    if (!($x > 0))
    {
        if (!($x < 0))
        {
            return true;
        }
    }
    return false;
}
---

=== if with chained comparison
def in_range(x: int) -> bool:
    if 0 < x < 10:
        return True
    return False
--- javascript
function inRange(x) {
  if (0 < x && x < 10) {
    return true;
  }
  return false;
}
--- typescript
function inRange(x: number): boolean {
  if (0 < x && x < 10) {
    return true;
  }
  return false;
}
--- ruby
def in_range(x)
  if 0 < x && x < 10
    return true
  end
  false
end
--- lua
function in_range(x)
  if 0 < x and x < 10 then
    return true
  end
  return false
end
--- perl
sub in_range ($x) {
    if (0 < $x && $x < 10) {
        return 1;
    }
    return 0;
}
--- php
function inRange(int $x): bool
{
    if (0 < $x && $x < 10)
    {
        return true;
    }
    return false;
}
---

=== if modifies variable
def clamp(x: int) -> int:
    result: int = x
    if x < 0:
        result = 0
    elif x > 100:
        result = 100
    return result
--- javascript
function clamp(x) {
  let result = x;
  if (x < 0) {
    result = 0;
  } else if (x > 100) {
    result = 100;
  }
  return result;
}
--- typescript
function clamp(x: number): number {
  let result: number = x;
  if (x < 0) {
    result = 0;
  } else if (x > 100) {
    result = 100;
  }
  return result;
}
--- ruby
def clamp(x)
  result = x
  if x < 0
    result = 0
  elsif x > 100
    result = 100
  end
  result
end
--- lua
function clamp(x)
  local result
  result = x
  if x < 0 then
    result = 0
  elseif x > 100 then
    result = 100
  end
  return result
end
--- perl
sub clamp ($x) {
    my $result = $x;
    if ($x < 0) {
        $result = 0;
    } elsif ($x > 100) {
        $result = 100;
    }
    return $result;
}
--- php
function clamp(int $x): int
{
    $result = $x;
    if ($x < 0)
    {
        $result = 0;
    }
    else
    {
        if ($x > 100)
        {
            $result = 100;
        }
    }
    return $result;
}
---

=== if with break
def find_first_positive(nums: list[int]) -> int:
    i: int = 0
    while i < len(nums):
        if nums[i] > 0:
            return nums[i]
        i = i + 1
    return -1
--- javascript
function findFirstPositive(nums) {
  let i = 0;
  while (i < nums.length) {
    if (nums[i] > 0) {
      return nums[i];
    }
    i = i + 1;
  }
  return -1;
}
--- typescript
function findFirstPositive(nums: number[]): number {
  let i: number = 0;
  while (i < nums.length) {
    if (nums[i] > 0) {
      return nums[i];
    }
    i = i + 1;
  }
  return -1;
}
--- ruby
def find_first_positive(nums)
  i = 0
  while i < nums.length
    if nums[i] > 0
      return nums[i]
    end
    i = i + 1
  end
  -1
end
--- lua
function find_first_positive(nums)
  local i
  i = 0
  while i < #nums do
    if nums[i + 1] > 0 then
      return nums[i + 1]
    end
    i = i + 1
  end
  return -1
end
--- perl
sub find_first_positive ($nums) {
    my $i = 0;
    while ($i < scalar(@{$nums})) {
        if ($nums->[$i] > 0) {
            return $nums->[$i];
        }
        $i = $i + 1;
    }
    return -1;
}
--- php
function findFirstPositive(?array $nums): int
{
    $i = 0;
    while ($i < count($nums))
    {
        if ($nums[$i] > 0)
        {
            return $nums[$i];
        }
        $i = $i + 1;
    }
    return -1;
}
---

=== if with continue
def count_positive(nums: list[int]) -> int:
    count: int = 0
    i: int = 0
    while i < len(nums):
        if nums[i] <= 0:
            i = i + 1
            continue
        count = count + 1
        i = i + 1
    return count
--- javascript
function countPositive(nums) {
  let count = 0;
  let i = 0;
  while (i < nums.length) {
    if (nums[i] <= 0) {
      i = i + 1;
      continue;
    }
    count = count + 1;
    i = i + 1;
  }
  return count;
}
--- typescript
function countPositive(nums: number[]): number {
  let count: number = 0;
  let i: number = 0;
  while (i < nums.length) {
    if (nums[i] <= 0) {
      i = i + 1;
      continue;
    }
    count = count + 1;
    i = i + 1;
  }
  return count;
}
--- ruby
def count_positive(nums)
  count = 0
  i = 0
  while i < nums.length
    if nums[i] <= 0
      i = i + 1
      next
    end
    count = count + 1
    i = i + 1
  end
  count
end
--- lua
function count_positive(nums)
  local count, i
  count = 0
  i = 0
  while i < #nums do
    if nums[i + 1] <= 0 then
      i = i + 1
      goto continue
    end
    count = count + 1
    i = i + 1
    ::continue::
  end
  return count
end
--- perl
sub count_positive ($nums) {
    my $count = 0;
    my $i = 0;
    while ($i < scalar(@{$nums})) {
        if ($nums->[$i] <= 0) {
            $i = $i + 1;
            next;
        }
        $count = $count + 1;
        $i = $i + 1;
    }
    return $count;
}
--- php
function countPositive(?array $nums): int
{
    $count = 0;
    $i = 0;
    while ($i < count($nums))
    {
        if ($nums[$i] <= 0)
        {
            $i = $i + 1;
            continue;
        }
        $count = $count + 1;
        $i = $i + 1;
    }
    return $count;
}
---

=== ternary assigns to variable
def pick_value(flag: bool) -> int:
    x: int = 10 if flag else 20
    return x
--- javascript
function pickValue(flag) {
  let x = flag ? 10 : 20;
  return x;
}
--- typescript
function pickValue(flag: boolean): number {
  let x: number = flag ? 10 : 20;
  return x;
}
--- ruby
def pick_value(flag)
  x = flag ? 10 : 20
  x
end
--- lua
function pick_value(flag)
  local x
  x = (flag and 10 or 20)
  return x
end
--- perl
sub pick_value ($flag) {
    my $x = ($flag ? 10 : 20);
    return $x;
}
--- php
function pickValue(bool $flag): int
{
    $x = $flag ? 10 : 20;
    return $x;
}
---

=== multiple conditions same block
def multi_check(a: int, b: int, c: int) -> bool:
    if a > 0:
        if b > 0:
            if c > 0:
                return True
    return False
--- javascript
function multiCheck(a, b, c) {
  if (a > 0) {
    if (b > 0) {
      if (c > 0) {
        return true;
      }
    }
  }
  return false;
}
--- typescript
function multiCheck(a: number, b: number, c: number): boolean {
  if (a > 0) {
    if (b > 0) {
      if (c > 0) {
        return true;
      }
    }
  }
  return false;
}
--- ruby
def multi_check(a, b, c)
  if a > 0
    if b > 0
      if c > 0
        return true
      end
    end
  end
  false
end
--- lua
function multi_check(a, b, c)
  if a > 0 then
    if b > 0 then
      if c > 0 then
        return true
      end
    end
  end
  return false
end
--- perl
sub multi_check ($a, $b, $c) {
    if ($a > 0) {
        if ($b > 0) {
            if ($c > 0) {
                return 1;
            }
        }
    }
    return 0;
}
--- php
function multiCheck(int $a, int $b, int $c): bool
{
    if ($a > 0)
    {
        if ($b > 0)
        {
            if ($c > 0)
            {
                return true;
            }
        }
    }
    return false;
}
---

=== early return pattern
def validate(x: int) -> bool:
    if x < 0:
        return False
    if x > 100:
        return False
    return True
--- javascript
function validate(x) {
  if (x < 0) {
    return false;
  }
  if (x > 100) {
    return false;
  }
  return true;
}
--- typescript
function validate(x: number): boolean {
  if (x < 0) {
    return false;
  }
  if (x > 100) {
    return false;
  }
  return true;
}
--- ruby
def validate(x)
  if x < 0
    return false
  end
  if x > 100
    return false
  end
  true
end
--- lua
function validate(x)
  if x < 0 then
    return false
  end
  if x > 100 then
    return false
  end
  return true
end
--- perl
sub validate ($x) {
    if ($x < 0) {
        return 0;
    }
    if ($x > 100) {
        return 0;
    }
    return 1;
}
--- php
function validate(int $x): bool
{
    if ($x < 0)
    {
        return false;
    }
    if ($x > 100)
    {
        return false;
    }
    return true;
}
---

=== guard clause
def process(x: int) -> int:
    if x == 0:
        return 0
    return x * 2
--- javascript
function process(x) {
  if (x === 0) {
    return 0;
  }
  return x * 2;
}
--- typescript
function process(x: number): number {
  if (x === 0) {
    return 0;
  }
  return x * 2;
}
--- ruby
def process(x)
  if x == 0
    return 0
  end
  x * 2
end
--- lua
function process(x)
  if x == 0 then
    return 0
  end
  return x * 2
end
--- perl
sub process ($x) {
    if ($x == 0) {
        return 0;
    }
    return $x * 2;
}
--- php
function process(int $x): int
{
    if ($x === 0)
    {
        return 0;
    }
    return $x * 2;
}
---

=== ternary with min
min(1, 2) if True else 0
--- javascript
true ? Math.min(1, 2) : 0;
--- typescript
true ? Math.min(1, 2) : 0;
--- ruby
true ? [1, 2].min : 0
--- lua
(true and math.min(1, 2) or 0)
--- perl
(1 ? (1 < 2 ? 1 : 2) : 0);
--- php
true ? min(1, 2) : 0;
---

=== ternary with max
max(1, 2) if True else 0
--- javascript
true ? Math.max(1, 2) : 0;
--- typescript
true ? Math.max(1, 2) : 0;
--- ruby
true ? [1, 2].max : 0
--- lua
(true and math.max(1, 2) or 0)
--- perl
(1 ? (1 > 2 ? 1 : 2) : 0);
--- php
true ? max(1, 2) : 0;
---

=== ternary float result
1.5 if True else 2.5
--- javascript
true ? 1.5 : 2.5;
--- typescript
true ? 1.5 : 2.5;
--- ruby
true ? 1.5 : 2.5
--- lua
(true and 1.5 or 2.5)
--- perl
(1 ? 1.5 : 2.5);
--- php
true ? 1.5 : 2.5;
---

=== if statement empty else
def maybe_double(x: int, do_it: bool) -> int:
    result: int = x
    if do_it:
        result = x * 2
    return result
--- javascript
function maybeDouble(x, doIt) {
  let result = x;
  if (doIt) {
    result = x * 2;
  }
  return result;
}
--- typescript
function maybeDouble(x: number, doIt: boolean): number {
  let result: number = x;
  if (doIt) {
    result = x * 2;
  }
  return result;
}
--- ruby
def maybe_double(x, do_it)
  result = x
  if do_it
    result = x * 2
  end
  result
end
--- lua
function maybe_double(x, do_it)
  local result
  result = x
  if do_it then
    result = x * 2
  end
  return result
end
--- perl
sub maybe_double ($x, $do_it) {
    my $result = $x;
    if ($do_it) {
        $result = $x * 2;
    }
    return $result;
}
--- php
function maybeDouble(int $x, bool $doIt): int
{
    $result = $x;
    if ($doIt)
    {
        $result = $x * 2;
    }
    return $result;
}
---

=== comparison chain in if
def ordered(a: int, b: int, c: int) -> bool:
    if a < b < c:
        return True
    return False
--- javascript
function ordered(a, b, c) {
  if (a < b && b < c) {
    return true;
  }
  return false;
}
--- typescript
function ordered(a: number, b: number, c: number): boolean {
  if (a < b && b < c) {
    return true;
  }
  return false;
}
--- ruby
def ordered(a, b, c)
  if a < b && b < c
    return true
  end
  false
end
--- lua
function ordered(a, b, c)
  if a < b and b < c then
    return true
  end
  return false
end
--- perl
sub ordered ($a, $b, $c) {
    if ($a < $b && $b < $c) {
        return 1;
    }
    return 0;
}
--- php
function ordered(int $a, int $b, int $c): bool
{
    if ($a < $b && $b < $c)
    {
        return true;
    }
    return false;
}
---

=== equality chain
def all_equal(a: int, b: int, c: int) -> bool:
    if a == b == c:
        return True
    return False
--- javascript
function allEqual(a, b, c) {
  if (a === b && b === c) {
    return true;
  }
  return false;
}
--- typescript
function allEqual(a: number, b: number, c: number): boolean {
  if (a === b && b === c) {
    return true;
  }
  return false;
}
--- ruby
def all_equal(a, b, c)
  if a == b && b == c
    return true
  end
  false
end
--- lua
function all_equal(a, b, c)
  if a == b and b == c then
    return true
  end
  return false
end
--- perl
sub all_equal ($a, $b, $c) {
    if ($a == $b && $b == $c) {
        return 1;
    }
    return 0;
}
--- php
function allEqual(int $a, int $b, int $c): bool
{
    if ($a === $b && $b === $c)
    {
        return true;
    }
    return false;
}
---
