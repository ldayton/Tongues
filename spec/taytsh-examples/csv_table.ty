-- CSV to formatted table
-- Reads CSV from stdin, prints an ASCII table to stdout.
-- Handles quoted fields with escaped quotes ("").

fn Main() -> void {
    let input: string = ReadAll()
    let rows: list[list[string]] = ParseCsv(input)
    if Len(rows) == 0 {
        return
    }
    try {
        ValidateRows(rows)
    } catch e: ValueError {
        WritelnErr(Concat("error: ", e.message))
        Exit(1)
    }
    let widths: map[int, int] = ComputeWidths(rows)
    PrintTable(rows, widths)
}

fn ParseCsv(input: string) -> list[list[string]] {
    let lines: list[string] = Split(input, "\n")
    let rows: list[list[string]]
    for line in lines {
        let trimmed: string = Trim(line, " \t\r")
        if trimmed == "" {
            continue
        }
        Append(rows, ParseRow(trimmed))
    }
    return rows
}

fn ParseRow(line: string) -> list[string] {
    let fields: list[string]
    let buf: string = ""
    let quoted: bool = false
    let i: int = 0
    while i < Len(line) {
        let ch: rune = line[i]
        if quoted {
            if ch == '"' {
                if i + 1 < Len(line) && line[i + 1] == '"' {
                    buf = Concat(buf, "\"")
                    i += 2
                    continue
                }
                quoted = false
            } else {
                buf = Concat(buf, ToString(ch))
            }
        } else if ch == '"' {
            quoted = true
        } else if ch == ',' {
            Append(fields, Trim(buf, " "))
            buf = ""
        } else {
            buf = Concat(buf, ToString(ch))
        }
        i += 1
    }
    if quoted {
        throw ValueError("unclosed quote")
    }
    Append(fields, Trim(buf, " "))
    return fields
}

fn ValidateRows(rows: list[list[string]]) -> void {
    let ncols: int = Len(rows[0])
    for i in range(1, Len(rows)) {
        let n: int = Len(rows[i])
        if n != ncols {
            throw ValueError(Format("row {} has {} fields, expected {}",
                ToString(i + 1), ToString(n), ToString(ncols)))
        }
    }
}

fn ComputeWidths(rows: list[list[string]]) -> map[int, int] {
    let widths: map[int, int] = Map()
    for row in rows {
        for c, field in row {
            let prev: int? = Get(widths, c)
            if prev == nil || Len(field) > prev {
                widths[c] = Len(field)
            }
        }
    }
    return widths
}

fn PadRight(s: string, width: int) -> string {
    let gap: int = width - Len(s)
    if gap <= 0 {
        return s
    }
    return Concat(s, Repeat(" ", gap))
}

fn Separator(ncols: int, widths: map[int, int]) -> string {
    let parts: list[string]
    for c in range(ncols) {
        Append(parts, Repeat("-", widths[c] + 2))
    }
    return Concat("+", Concat(Join("+", parts), "+"))
}

fn FormatRow(row: list[string], widths: map[int, int]) -> string {
    let cells: list[string]
    for i, field in row {
        Append(cells, Format(" {} ", PadRight(field, widths[i])))
    }
    return Concat("|", Concat(Join("|", cells), "|"))
}

fn PrintTable(rows: list[list[string]], widths: map[int, int]) -> void {
    let ncols: int = Len(rows[0])
    let sep: string = Separator(ncols, widths)
    WritelnOut(sep)
    WritelnOut(FormatRow(rows[0], widths))
    WritelnOut(sep)
    for i in range(1, Len(rows)) {
        WritelnOut(FormatRow(rows[i], widths))
    }
    if Len(rows) > 1 {
        WritelnOut(sep)
    }
}
